/* Generated from Java with JSweet 3.0.0 - http://www.jsweet.org */
namespace org.openprovenance.apache.commons.lang {
    /**
     * <p>ArrayUtils instances should NOT be constructed in standard programming.
     * Instead, the class should be used as <code>ArrayUtils.clone(new int[] {2})</code>.</p>
     * 
     * <p>This constructor is public to permit tools that require a JavaBean instance
     * to operate.</p>
     * @class
     * @author Apache Software Foundation
     */
    export class ArrayUtils {
        /**
         * An empty immutable <code>Object</code> array.
         */
        public static EMPTY_OBJECT_ARRAY: any[]; public static EMPTY_OBJECT_ARRAY_$LI$(): any[] { if (ArrayUtils.EMPTY_OBJECT_ARRAY == null) { ArrayUtils.EMPTY_OBJECT_ARRAY = []; }  return ArrayUtils.EMPTY_OBJECT_ARRAY; }

        /**
         * An empty immutable <code>Class</code> array.
         */
        public static EMPTY_CLASS_ARRAY: any[]; public static EMPTY_CLASS_ARRAY_$LI$(): any[] { if (ArrayUtils.EMPTY_CLASS_ARRAY == null) { ArrayUtils.EMPTY_CLASS_ARRAY = []; }  return ArrayUtils.EMPTY_CLASS_ARRAY; }

        /**
         * An empty immutable <code>String</code> array.
         */
        public static EMPTY_STRING_ARRAY: string[]; public static EMPTY_STRING_ARRAY_$LI$(): string[] { if (ArrayUtils.EMPTY_STRING_ARRAY == null) { ArrayUtils.EMPTY_STRING_ARRAY = []; }  return ArrayUtils.EMPTY_STRING_ARRAY; }

        /**
         * An empty immutable <code>long</code> array.
         */
        public static EMPTY_LONG_ARRAY: number[]; public static EMPTY_LONG_ARRAY_$LI$(): number[] { if (ArrayUtils.EMPTY_LONG_ARRAY == null) { ArrayUtils.EMPTY_LONG_ARRAY = []; }  return ArrayUtils.EMPTY_LONG_ARRAY; }

        /**
         * An empty immutable <code>Long</code> array.
         */
        public static EMPTY_LONG_OBJECT_ARRAY: number[]; public static EMPTY_LONG_OBJECT_ARRAY_$LI$(): number[] { if (ArrayUtils.EMPTY_LONG_OBJECT_ARRAY == null) { ArrayUtils.EMPTY_LONG_OBJECT_ARRAY = []; }  return ArrayUtils.EMPTY_LONG_OBJECT_ARRAY; }

        /**
         * An empty immutable <code>int</code> array.
         */
        public static EMPTY_INT_ARRAY: number[]; public static EMPTY_INT_ARRAY_$LI$(): number[] { if (ArrayUtils.EMPTY_INT_ARRAY == null) { ArrayUtils.EMPTY_INT_ARRAY = []; }  return ArrayUtils.EMPTY_INT_ARRAY; }

        /**
         * An empty immutable <code>Integer</code> array.
         */
        public static EMPTY_INTEGER_OBJECT_ARRAY: number[]; public static EMPTY_INTEGER_OBJECT_ARRAY_$LI$(): number[] { if (ArrayUtils.EMPTY_INTEGER_OBJECT_ARRAY == null) { ArrayUtils.EMPTY_INTEGER_OBJECT_ARRAY = []; }  return ArrayUtils.EMPTY_INTEGER_OBJECT_ARRAY; }

        /**
         * An empty immutable <code>short</code> array.
         */
        public static EMPTY_SHORT_ARRAY: number[]; public static EMPTY_SHORT_ARRAY_$LI$(): number[] { if (ArrayUtils.EMPTY_SHORT_ARRAY == null) { ArrayUtils.EMPTY_SHORT_ARRAY = []; }  return ArrayUtils.EMPTY_SHORT_ARRAY; }

        /**
         * An empty immutable <code>Short</code> array.
         */
        public static EMPTY_SHORT_OBJECT_ARRAY: number[]; public static EMPTY_SHORT_OBJECT_ARRAY_$LI$(): number[] { if (ArrayUtils.EMPTY_SHORT_OBJECT_ARRAY == null) { ArrayUtils.EMPTY_SHORT_OBJECT_ARRAY = []; }  return ArrayUtils.EMPTY_SHORT_OBJECT_ARRAY; }

        /**
         * An empty immutable <code>byte</code> array.
         */
        public static EMPTY_BYTE_ARRAY: number[]; public static EMPTY_BYTE_ARRAY_$LI$(): number[] { if (ArrayUtils.EMPTY_BYTE_ARRAY == null) { ArrayUtils.EMPTY_BYTE_ARRAY = []; }  return ArrayUtils.EMPTY_BYTE_ARRAY; }

        /**
         * An empty immutable <code>Byte</code> array.
         */
        public static EMPTY_BYTE_OBJECT_ARRAY: number[]; public static EMPTY_BYTE_OBJECT_ARRAY_$LI$(): number[] { if (ArrayUtils.EMPTY_BYTE_OBJECT_ARRAY == null) { ArrayUtils.EMPTY_BYTE_OBJECT_ARRAY = []; }  return ArrayUtils.EMPTY_BYTE_OBJECT_ARRAY; }

        /**
         * An empty immutable <code>double</code> array.
         */
        public static EMPTY_DOUBLE_ARRAY: number[]; public static EMPTY_DOUBLE_ARRAY_$LI$(): number[] { if (ArrayUtils.EMPTY_DOUBLE_ARRAY == null) { ArrayUtils.EMPTY_DOUBLE_ARRAY = []; }  return ArrayUtils.EMPTY_DOUBLE_ARRAY; }

        /**
         * An empty immutable <code>Double</code> array.
         */
        public static EMPTY_DOUBLE_OBJECT_ARRAY: number[]; public static EMPTY_DOUBLE_OBJECT_ARRAY_$LI$(): number[] { if (ArrayUtils.EMPTY_DOUBLE_OBJECT_ARRAY == null) { ArrayUtils.EMPTY_DOUBLE_OBJECT_ARRAY = []; }  return ArrayUtils.EMPTY_DOUBLE_OBJECT_ARRAY; }

        /**
         * An empty immutable <code>float</code> array.
         */
        public static EMPTY_FLOAT_ARRAY: number[]; public static EMPTY_FLOAT_ARRAY_$LI$(): number[] { if (ArrayUtils.EMPTY_FLOAT_ARRAY == null) { ArrayUtils.EMPTY_FLOAT_ARRAY = []; }  return ArrayUtils.EMPTY_FLOAT_ARRAY; }

        /**
         * An empty immutable <code>Float</code> array.
         */
        public static EMPTY_FLOAT_OBJECT_ARRAY: number[]; public static EMPTY_FLOAT_OBJECT_ARRAY_$LI$(): number[] { if (ArrayUtils.EMPTY_FLOAT_OBJECT_ARRAY == null) { ArrayUtils.EMPTY_FLOAT_OBJECT_ARRAY = []; }  return ArrayUtils.EMPTY_FLOAT_OBJECT_ARRAY; }

        /**
         * An empty immutable <code>boolean</code> array.
         */
        public static EMPTY_BOOLEAN_ARRAY: boolean[]; public static EMPTY_BOOLEAN_ARRAY_$LI$(): boolean[] { if (ArrayUtils.EMPTY_BOOLEAN_ARRAY == null) { ArrayUtils.EMPTY_BOOLEAN_ARRAY = []; }  return ArrayUtils.EMPTY_BOOLEAN_ARRAY; }

        /**
         * An empty immutable <code>Boolean</code> array.
         */
        public static EMPTY_BOOLEAN_OBJECT_ARRAY: boolean[]; public static EMPTY_BOOLEAN_OBJECT_ARRAY_$LI$(): boolean[] { if (ArrayUtils.EMPTY_BOOLEAN_OBJECT_ARRAY == null) { ArrayUtils.EMPTY_BOOLEAN_OBJECT_ARRAY = []; }  return ArrayUtils.EMPTY_BOOLEAN_OBJECT_ARRAY; }

        /**
         * An empty immutable <code>char</code> array.
         */
        public static EMPTY_CHAR_ARRAY: string[]; public static EMPTY_CHAR_ARRAY_$LI$(): string[] { if (ArrayUtils.EMPTY_CHAR_ARRAY == null) { ArrayUtils.EMPTY_CHAR_ARRAY = []; }  return ArrayUtils.EMPTY_CHAR_ARRAY; }

        /**
         * An empty immutable <code>Character</code> array.
         */
        public static EMPTY_CHARACTER_OBJECT_ARRAY: string[]; public static EMPTY_CHARACTER_OBJECT_ARRAY_$LI$(): string[] { if (ArrayUtils.EMPTY_CHARACTER_OBJECT_ARRAY == null) { ArrayUtils.EMPTY_CHARACTER_OBJECT_ARRAY = []; }  return ArrayUtils.EMPTY_CHARACTER_OBJECT_ARRAY; }

        /**
         * The index value when an element is not found in a list or array: <code>-1</code>.
         * This value is returned by methods in this class and can also be used in comparisons with values returned by
         * various method from {@link java.util.List}.
         */
        public static INDEX_NOT_FOUND: number = -1;

        public constructor() {
        }

        public static toString$java_lang_Object(array: any): string {
            return ArrayUtils.toString$java_lang_Object$java_lang_String(array, "{}");
        }

        public static toString$java_lang_Object$java_lang_String(array: any, stringIfNull: string): string {
            if (array == null){
                return stringIfNull;
            }
            return new org.openprovenance.apache.commons.lang.builder.ToStringBuilder(array, org.openprovenance.apache.commons.lang.builder.ToStringStyle.SIMPLE_STYLE_$LI$()).append$java_lang_Object(array).toString();
        }

        /**
         * <p>Outputs an array as a String handling <code>null</code>s.</p>
         * 
         * <p>Multi-dimensional arrays are handled correctly, including
         * multi-dimensional primitive arrays.</p>
         * 
         * <p>The format is that of Java source code, for example <code>{a,b}</code>.</p>
         * 
         * @param {*} array  the array to get a toString for, may be <code>null</code>
         * @param {string} stringIfNull  the String to return if the array is <code>null</code>
         * @return {string} a String representation of the array
         */
        public static toString(array?: any, stringIfNull?: any): any {
            if (((array != null) || array === null) && ((typeof stringIfNull === 'string') || stringIfNull === null)) {
                return <any>org.openprovenance.apache.commons.lang.ArrayUtils.toString$java_lang_Object$java_lang_String(array, stringIfNull);
            } else if (((array != null) || array === null) && stringIfNull === undefined) {
                return <any>org.openprovenance.apache.commons.lang.ArrayUtils.toString$java_lang_Object(array);
            } else throw new Error('invalid overload');
        }

        /**
         * <p>Get a hashCode for an array handling multi-dimensional arrays correctly.</p>
         * 
         * <p>Multi-dimensional primitive arrays are also handled correctly by this method.</p>
         * 
         * @param {*} array  the array to get a hashCode for, may be <code>null</code>
         * @return {number} a hashCode for the array, zero if null array input
         */
        public static hashCode(array: any): number {
            return new org.openprovenance.apache.commons.lang.builder.HashCodeBuilder().append$java_lang_Object(array).toHashCode();
        }

        /**
         * <p>Compares two arrays, using equals(), handling multi-dimensional arrays
         * correctly.</p>
         * 
         * <p>Multi-dimensional primitive arrays are also handled correctly by this method.</p>
         * 
         * @param {*} array1  the left hand array to compare, may be <code>null</code>
         * @param {*} array2  the right hand array to compare, may be <code>null</code>
         * @return {boolean} <code>true</code> if the arrays are equal
         */
        public static isEquals(array1: any, array2: any): boolean {
            return new org.openprovenance.apache.commons.lang.builder.EqualsBuilder().append$java_lang_Object$java_lang_Object(array1, array2).isEquals();
        }

        /**
         * <p>Converts the given array into a {@link Map}. Each element of the array
         * must be either a {@link Map.Entry} or an Array, containing at least two
         * elements, where the first element is used as key and the second as
         * value.</p>
         * 
         * <p>This method can be used to initialize:</p>
         * <pre>
         * // Create a Map mapping colors.
         * Map colorMap = MapUtils.toMap(new String[][] {{
         * {"RED", "#FF0000"},
         * {"GREEN", "#00FF00"},
         * {"BLUE", "#0000FF"}});
         * </pre>
         * 
         * <p>This method returns <code>null</code> for a <code>null</code> input array.</p>
         * 
         * @param {java.lang.Object[]} array  an array whose elements are either a {@link Map.Entry} or
         * an Array containing at least two elements, may be <code>null</code>
         * @return {*} a <code>Map</code> that was created from the array
         * @throws IllegalArgumentException  if one element of this Array is
         * itself an Array containing less then two elements
         * @throws IllegalArgumentException  if the array contains elements other
         * than {@link Map.Entry} and an Array
         */
        public static toMap(array: any[]): any {
            if (array == null){
                return null;
            }
            const map: any = <any>({});
            for(let i: number = 0; i < array.length; i++) {{
                const object: any = array[i];
                if (object != null && (object.constructor != null && object.constructor["__interfaces"] != null && object.constructor["__interfaces"].indexOf("java.util.Map.Entry") >= 0)){
                    const entry: java.util.Map.Entry<any, any> = <java.util.Map.Entry<any, any>><any>object;
                    /* put */((m,k,v) => { if(m.entries==null) m.entries=[]; for(let i=0;i<m.entries.length;i++) if(m.entries[i].key==null && k==null || m.entries[i].key.equals!=null && m.entries[i].key.equals(k) || m.entries[i].key===k) { m.entries[i].value=v; return; } m.entries.push({key:k,value:v,getKey: function() { return this.key }, getValue: function() { return this.value }}); })(<any>map, entry.getKey(), entry.getValue());
                } else if (object != null && object instanceof <any>Array && (object.length == 0 || object[0] == null ||object[0] != null)){
                    const entry: any[] = <any[]>object;
                    if (entry.length < 2){
                        throw Object.defineProperty(new Error("Array element " + i + ", \'" + object + "\', has a length less than 2"), '__classes', { configurable: true, value: ['java.lang.Throwable','java.lang.Object','java.lang.RuntimeException','java.lang.IllegalArgumentException','java.lang.Exception'] });
                    }
                    /* put */((m,k,v) => { if(m.entries==null) m.entries=[]; for(let i=0;i<m.entries.length;i++) if(m.entries[i].key==null && k==null || m.entries[i].key.equals!=null && m.entries[i].key.equals(k) || m.entries[i].key===k) { m.entries[i].value=v; return; } m.entries.push({key:k,value:v,getKey: function() { return this.key }, getValue: function() { return this.value }}); })(<any>map, entry[0], entry[1]);
                } else {
                    throw Object.defineProperty(new Error("Array element " + i + ", \'" + object + "\', is neither of type Map.Entry nor an Array"), '__classes', { configurable: true, value: ['java.lang.Throwable','java.lang.Object','java.lang.RuntimeException','java.lang.IllegalArgumentException','java.lang.Exception'] });
                }
            };}
            return map;
        }

        public static clone$java_lang_Object_A(array: any[]): any[] {
            if (array == null){
                return null;
            }
            return <any[]>/* clone */array.slice(0);
        }

        /**
         * <p>Shallow clones an array returning a typecast result and handling
         * <code>null</code>.</p>
         * 
         * <p>The objects in the array are not cloned, thus there is no special
         * handling for multi-dimensional arrays.</p>
         * 
         * <p>This method returns <code>null</code> for a <code>null</code> input array.</p>
         * 
         * @param {java.lang.Object[]} array  the array to shallow clone, may be <code>null</code>
         * @return {java.lang.Object[]} the cloned array, <code>null</code> if <code>null</code> input
         */
        public static clone(array?: any): any {
            if (((array != null && array instanceof <any>Array && (array.length == 0 || array[0] == null ||(array[0] != null))) || array === null)) {
                return <any>org.openprovenance.apache.commons.lang.ArrayUtils.clone$java_lang_Object_A(array);
            } else if (((array != null && array instanceof <any>Array && (array.length == 0 || array[0] == null ||(typeof array[0] === 'number'))) || array === null)) {
                return <any>org.openprovenance.apache.commons.lang.ArrayUtils.clone$long_A(array);
            } else if (((array != null && array instanceof <any>Array && (array.length == 0 || array[0] == null ||(typeof array[0] === 'number'))) || array === null)) {
                return <any>org.openprovenance.apache.commons.lang.ArrayUtils.clone$int_A(array);
            } else if (((array != null && array instanceof <any>Array && (array.length == 0 || array[0] == null ||(typeof array[0] === 'number'))) || array === null)) {
                return <any>org.openprovenance.apache.commons.lang.ArrayUtils.clone$short_A(array);
            } else if (((array != null && array instanceof <any>Array && (array.length == 0 || array[0] == null ||(typeof array[0] === 'string'))) || array === null)) {
                return <any>org.openprovenance.apache.commons.lang.ArrayUtils.clone$char_A(array);
            } else if (((array != null && array instanceof <any>Array && (array.length == 0 || array[0] == null ||(typeof array[0] === 'number'))) || array === null)) {
                return <any>org.openprovenance.apache.commons.lang.ArrayUtils.clone$byte_A(array);
            } else if (((array != null && array instanceof <any>Array && (array.length == 0 || array[0] == null ||(typeof array[0] === 'number'))) || array === null)) {
                return <any>org.openprovenance.apache.commons.lang.ArrayUtils.clone$double_A(array);
            } else if (((array != null && array instanceof <any>Array && (array.length == 0 || array[0] == null ||(typeof array[0] === 'number'))) || array === null)) {
                return <any>org.openprovenance.apache.commons.lang.ArrayUtils.clone$float_A(array);
            } else if (((array != null && array instanceof <any>Array && (array.length == 0 || array[0] == null ||(typeof array[0] === 'boolean'))) || array === null)) {
                return <any>org.openprovenance.apache.commons.lang.ArrayUtils.clone$boolean_A(array);
            } else throw new Error('invalid overload');
        }

        public static clone$long_A(array: number[]): number[] {
            if (array == null){
                return null;
            }
            return <number[]>/* clone */array.slice(0);
        }

        public static clone$int_A(array: number[]): number[] {
            if (array == null){
                return null;
            }
            return <number[]>/* clone */array.slice(0);
        }

        public static clone$short_A(array: number[]): number[] {
            if (array == null){
                return null;
            }
            return <number[]>/* clone */array.slice(0);
        }

        public static clone$char_A(array: string[]): string[] {
            if (array == null){
                return null;
            }
            return <string[]>/* clone */array.slice(0);
        }

        public static clone$byte_A(array: number[]): number[] {
            if (array == null){
                return null;
            }
            return <number[]>/* clone */array.slice(0);
        }

        public static clone$double_A(array: number[]): number[] {
            if (array == null){
                return null;
            }
            return <number[]>/* clone */array.slice(0);
        }

        public static clone$float_A(array: number[]): number[] {
            if (array == null){
                return null;
            }
            return <number[]>/* clone */array.slice(0);
        }

        public static clone$boolean_A(array: boolean[]): boolean[] {
            if (array == null){
                return null;
            }
            return <boolean[]>/* clone */array.slice(0);
        }

        public static nullToEmpty$java_lang_Object_A(array: any[]): any[] {
            if (array == null || array.length === 0){
                return ArrayUtils.EMPTY_OBJECT_ARRAY_$LI$();
            }
            return array;
        }

        public static nullToEmpty$java_lang_String_A(array: string[]): string[] {
            if (array == null || array.length === 0){
                return ArrayUtils.EMPTY_STRING_ARRAY_$LI$();
            }
            return array;
        }

        /**
         * <p>Defensive programming technique to change a <code>null</code>
         * reference to an empty one.</p>
         * 
         * <p>This method returns an empty array for a <code>null</code> input array.</p>
         * 
         * <p>As a memory optimizing technique an empty array passed in will be overridden with
         * the empty <code>public static</code> references in this class.</p>
         * 
         * @param {java.lang.String[]} array  the array to check for <code>null</code> or empty
         * @return {java.lang.String[]} the same array, <code>public static</code> empty array if <code>null</code> or empty input
         * @since 2.5
         */
        public static nullToEmpty(array?: any): any {
            if (((array != null && array instanceof <any>Array && (array.length == 0 || array[0] == null ||(typeof array[0] === 'string'))) || array === null)) {
                return <any>org.openprovenance.apache.commons.lang.ArrayUtils.nullToEmpty$java_lang_String_A(array);
            } else if (((array != null && array instanceof <any>Array && (array.length == 0 || array[0] == null ||(array[0] != null))) || array === null)) {
                return <any>org.openprovenance.apache.commons.lang.ArrayUtils.nullToEmpty$java_lang_Object_A(array);
            } else if (((array != null && array instanceof <any>Array && (array.length == 0 || array[0] == null ||(typeof array[0] === 'number'))) || array === null)) {
                return <any>org.openprovenance.apache.commons.lang.ArrayUtils.nullToEmpty$long_A(array);
            } else if (((array != null && array instanceof <any>Array && (array.length == 0 || array[0] == null ||(typeof array[0] === 'number'))) || array === null)) {
                return <any>org.openprovenance.apache.commons.lang.ArrayUtils.nullToEmpty$int_A(array);
            } else if (((array != null && array instanceof <any>Array && (array.length == 0 || array[0] == null ||(typeof array[0] === 'number'))) || array === null)) {
                return <any>org.openprovenance.apache.commons.lang.ArrayUtils.nullToEmpty$short_A(array);
            } else if (((array != null && array instanceof <any>Array && (array.length == 0 || array[0] == null ||(typeof array[0] === 'string'))) || array === null)) {
                return <any>org.openprovenance.apache.commons.lang.ArrayUtils.nullToEmpty$char_A(array);
            } else if (((array != null && array instanceof <any>Array && (array.length == 0 || array[0] == null ||(typeof array[0] === 'number'))) || array === null)) {
                return <any>org.openprovenance.apache.commons.lang.ArrayUtils.nullToEmpty$byte_A(array);
            } else if (((array != null && array instanceof <any>Array && (array.length == 0 || array[0] == null ||(typeof array[0] === 'number'))) || array === null)) {
                return <any>org.openprovenance.apache.commons.lang.ArrayUtils.nullToEmpty$double_A(array);
            } else if (((array != null && array instanceof <any>Array && (array.length == 0 || array[0] == null ||(typeof array[0] === 'number'))) || array === null)) {
                return <any>org.openprovenance.apache.commons.lang.ArrayUtils.nullToEmpty$float_A(array);
            } else if (((array != null && array instanceof <any>Array && (array.length == 0 || array[0] == null ||(typeof array[0] === 'boolean'))) || array === null)) {
                return <any>org.openprovenance.apache.commons.lang.ArrayUtils.nullToEmpty$boolean_A(array);
            } else if (((array != null && array instanceof <any>Array && (array.length == 0 || array[0] == null ||(typeof array[0] === 'number'))) || array === null)) {
                return <any>org.openprovenance.apache.commons.lang.ArrayUtils.nullToEmpty$java_lang_Long_A(array);
            } else if (((array != null && array instanceof <any>Array && (array.length == 0 || array[0] == null ||(typeof array[0] === 'number'))) || array === null)) {
                return <any>org.openprovenance.apache.commons.lang.ArrayUtils.nullToEmpty$java_lang_Integer_A(array);
            } else if (((array != null && array instanceof <any>Array && (array.length == 0 || array[0] == null ||(typeof array[0] === 'number'))) || array === null)) {
                return <any>org.openprovenance.apache.commons.lang.ArrayUtils.nullToEmpty$java_lang_Short_A(array);
            } else if (((array != null && array instanceof <any>Array && (array.length == 0 || array[0] == null ||(typeof array[0] === 'string'))) || array === null)) {
                return <any>org.openprovenance.apache.commons.lang.ArrayUtils.nullToEmpty$java_lang_Character_A(array);
            } else if (((array != null && array instanceof <any>Array && (array.length == 0 || array[0] == null ||(typeof array[0] === 'number'))) || array === null)) {
                return <any>org.openprovenance.apache.commons.lang.ArrayUtils.nullToEmpty$java_lang_Byte_A(array);
            } else if (((array != null && array instanceof <any>Array && (array.length == 0 || array[0] == null ||(typeof array[0] === 'number'))) || array === null)) {
                return <any>org.openprovenance.apache.commons.lang.ArrayUtils.nullToEmpty$java_lang_Double_A(array);
            } else if (((array != null && array instanceof <any>Array && (array.length == 0 || array[0] == null ||(typeof array[0] === 'number'))) || array === null)) {
                return <any>org.openprovenance.apache.commons.lang.ArrayUtils.nullToEmpty$java_lang_Float_A(array);
            } else if (((array != null && array instanceof <any>Array && (array.length == 0 || array[0] == null ||(typeof array[0] === 'boolean'))) || array === null)) {
                return <any>org.openprovenance.apache.commons.lang.ArrayUtils.nullToEmpty$java_lang_Boolean_A(array);
            } else throw new Error('invalid overload');
        }

        public static nullToEmpty$long_A(array: number[]): number[] {
            if (array == null || array.length === 0){
                return ArrayUtils.EMPTY_LONG_ARRAY_$LI$();
            }
            return array;
        }

        public static nullToEmpty$int_A(array: number[]): number[] {
            if (array == null || array.length === 0){
                return ArrayUtils.EMPTY_INT_ARRAY_$LI$();
            }
            return array;
        }

        public static nullToEmpty$short_A(array: number[]): number[] {
            if (array == null || array.length === 0){
                return ArrayUtils.EMPTY_SHORT_ARRAY_$LI$();
            }
            return array;
        }

        public static nullToEmpty$char_A(array: string[]): string[] {
            if (array == null || array.length === 0){
                return ArrayUtils.EMPTY_CHAR_ARRAY_$LI$();
            }
            return array;
        }

        public static nullToEmpty$byte_A(array: number[]): number[] {
            if (array == null || array.length === 0){
                return ArrayUtils.EMPTY_BYTE_ARRAY_$LI$();
            }
            return array;
        }

        public static nullToEmpty$double_A(array: number[]): number[] {
            if (array == null || array.length === 0){
                return ArrayUtils.EMPTY_DOUBLE_ARRAY_$LI$();
            }
            return array;
        }

        public static nullToEmpty$float_A(array: number[]): number[] {
            if (array == null || array.length === 0){
                return ArrayUtils.EMPTY_FLOAT_ARRAY_$LI$();
            }
            return array;
        }

        public static nullToEmpty$boolean_A(array: boolean[]): boolean[] {
            if (array == null || array.length === 0){
                return ArrayUtils.EMPTY_BOOLEAN_ARRAY_$LI$();
            }
            return array;
        }

        public static nullToEmpty$java_lang_Long_A(array: number[]): number[] {
            if (array == null || array.length === 0){
                return ArrayUtils.EMPTY_LONG_OBJECT_ARRAY_$LI$();
            }
            return array;
        }

        public static nullToEmpty$java_lang_Integer_A(array: number[]): number[] {
            if (array == null || array.length === 0){
                return ArrayUtils.EMPTY_INTEGER_OBJECT_ARRAY_$LI$();
            }
            return array;
        }

        public static nullToEmpty$java_lang_Short_A(array: number[]): number[] {
            if (array == null || array.length === 0){
                return ArrayUtils.EMPTY_SHORT_OBJECT_ARRAY_$LI$();
            }
            return array;
        }

        public static nullToEmpty$java_lang_Character_A(array: string[]): string[] {
            if (array == null || array.length === 0){
                return ArrayUtils.EMPTY_CHARACTER_OBJECT_ARRAY_$LI$();
            }
            return array;
        }

        public static nullToEmpty$java_lang_Byte_A(array: number[]): number[] {
            if (array == null || array.length === 0){
                return ArrayUtils.EMPTY_BYTE_OBJECT_ARRAY_$LI$();
            }
            return array;
        }

        public static nullToEmpty$java_lang_Double_A(array: number[]): number[] {
            if (array == null || array.length === 0){
                return ArrayUtils.EMPTY_DOUBLE_OBJECT_ARRAY_$LI$();
            }
            return array;
        }

        public static nullToEmpty$java_lang_Float_A(array: number[]): number[] {
            if (array == null || array.length === 0){
                return ArrayUtils.EMPTY_FLOAT_OBJECT_ARRAY_$LI$();
            }
            return array;
        }

        public static nullToEmpty$java_lang_Boolean_A(array: boolean[]): boolean[] {
            if (array == null || array.length === 0){
                return ArrayUtils.EMPTY_BOOLEAN_OBJECT_ARRAY_$LI$();
            }
            return array;
        }

        public static subarray$java_lang_Object_A$int$int(array: any[], startIndexInclusive: number, endIndexExclusive: number): any[] {
            if (array == null){
                return null;
            }
            if (startIndexInclusive < 0){
                startIndexInclusive = 0;
            }
            if (endIndexExclusive > array.length){
                endIndexExclusive = array.length;
            }
            const newSize: number = endIndexExclusive - startIndexInclusive;
            const type: any = (<any>array.constructor).getComponentType();
            if (newSize <= 0){
                return <any[]>/* newInstance */new Array<any>(0);
            }
            const subarray: any[] = <any[]>/* newInstance */new Array<any>(newSize);
            /* arraycopy */((srcPts, srcOff, dstPts, dstOff, size) => { if(srcPts !== dstPts || dstOff >= srcOff + size) { while (--size >= 0) dstPts[dstOff++] = srcPts[srcOff++];} else { let tmp = srcPts.slice(srcOff, srcOff + size); for (let i = 0; i < size; i++) dstPts[dstOff++] = tmp[i]; }})(array, startIndexInclusive, subarray, 0, newSize);
            return subarray;
        }

        /**
         * <p>Produces a new array containing the elements between
         * the start and end indices.</p>
         * 
         * <p>The start index is inclusive, the end index exclusive.
         * Null array input produces null output.</p>
         * 
         * <p>The component type of the subarray is always the same as
         * that of the input array. Thus, if the input is an array of type
         * <code>Date</code>, the following usage is envisaged:</p>
         * 
         * <pre>
         * Date[] someDates = (Date[])ArrayUtils.subarray(allDates, 2, 5);
         * </pre>
         * 
         * @param {java.lang.Object[]} array  the array
         * @param {number} startIndexInclusive  the starting index. Undervalue (&lt;0)
         * is promoted to 0, overvalue (&gt;array.length) results
         * in an empty array.
         * @param {number} endIndexExclusive  elements up to endIndex-1 are present in the
         * returned subarray. Undervalue (&lt; startIndex) produces
         * empty array, overvalue (&gt;array.length) is demoted to
         * array length.
         * @return {java.lang.Object[]} a new array containing the elements between
         * the start and end indices.
         * @since 2.1
         */
        public static subarray(array?: any, startIndexInclusive?: any, endIndexExclusive?: any): any {
            if (((array != null && array instanceof <any>Array && (array.length == 0 || array[0] == null ||(array[0] != null))) || array === null) && ((typeof startIndexInclusive === 'number') || startIndexInclusive === null) && ((typeof endIndexExclusive === 'number') || endIndexExclusive === null)) {
                return <any>org.openprovenance.apache.commons.lang.ArrayUtils.subarray$java_lang_Object_A$int$int(array, startIndexInclusive, endIndexExclusive);
            } else if (((array != null && array instanceof <any>Array && (array.length == 0 || array[0] == null ||(typeof array[0] === 'number'))) || array === null) && ((typeof startIndexInclusive === 'number') || startIndexInclusive === null) && ((typeof endIndexExclusive === 'number') || endIndexExclusive === null)) {
                return <any>org.openprovenance.apache.commons.lang.ArrayUtils.subarray$long_A$int$int(array, startIndexInclusive, endIndexExclusive);
            } else if (((array != null && array instanceof <any>Array && (array.length == 0 || array[0] == null ||(typeof array[0] === 'number'))) || array === null) && ((typeof startIndexInclusive === 'number') || startIndexInclusive === null) && ((typeof endIndexExclusive === 'number') || endIndexExclusive === null)) {
                return <any>org.openprovenance.apache.commons.lang.ArrayUtils.subarray$int_A$int$int(array, startIndexInclusive, endIndexExclusive);
            } else if (((array != null && array instanceof <any>Array && (array.length == 0 || array[0] == null ||(typeof array[0] === 'number'))) || array === null) && ((typeof startIndexInclusive === 'number') || startIndexInclusive === null) && ((typeof endIndexExclusive === 'number') || endIndexExclusive === null)) {
                return <any>org.openprovenance.apache.commons.lang.ArrayUtils.subarray$short_A$int$int(array, startIndexInclusive, endIndexExclusive);
            } else if (((array != null && array instanceof <any>Array && (array.length == 0 || array[0] == null ||(typeof array[0] === 'string'))) || array === null) && ((typeof startIndexInclusive === 'number') || startIndexInclusive === null) && ((typeof endIndexExclusive === 'number') || endIndexExclusive === null)) {
                return <any>org.openprovenance.apache.commons.lang.ArrayUtils.subarray$char_A$int$int(array, startIndexInclusive, endIndexExclusive);
            } else if (((array != null && array instanceof <any>Array && (array.length == 0 || array[0] == null ||(typeof array[0] === 'number'))) || array === null) && ((typeof startIndexInclusive === 'number') || startIndexInclusive === null) && ((typeof endIndexExclusive === 'number') || endIndexExclusive === null)) {
                return <any>org.openprovenance.apache.commons.lang.ArrayUtils.subarray$byte_A$int$int(array, startIndexInclusive, endIndexExclusive);
            } else if (((array != null && array instanceof <any>Array && (array.length == 0 || array[0] == null ||(typeof array[0] === 'number'))) || array === null) && ((typeof startIndexInclusive === 'number') || startIndexInclusive === null) && ((typeof endIndexExclusive === 'number') || endIndexExclusive === null)) {
                return <any>org.openprovenance.apache.commons.lang.ArrayUtils.subarray$double_A$int$int(array, startIndexInclusive, endIndexExclusive);
            } else if (((array != null && array instanceof <any>Array && (array.length == 0 || array[0] == null ||(typeof array[0] === 'number'))) || array === null) && ((typeof startIndexInclusive === 'number') || startIndexInclusive === null) && ((typeof endIndexExclusive === 'number') || endIndexExclusive === null)) {
                return <any>org.openprovenance.apache.commons.lang.ArrayUtils.subarray$float_A$int$int(array, startIndexInclusive, endIndexExclusive);
            } else if (((array != null && array instanceof <any>Array && (array.length == 0 || array[0] == null ||(typeof array[0] === 'boolean'))) || array === null) && ((typeof startIndexInclusive === 'number') || startIndexInclusive === null) && ((typeof endIndexExclusive === 'number') || endIndexExclusive === null)) {
                return <any>org.openprovenance.apache.commons.lang.ArrayUtils.subarray$boolean_A$int$int(array, startIndexInclusive, endIndexExclusive);
            } else throw new Error('invalid overload');
        }

        public static subarray$long_A$int$int(array: number[], startIndexInclusive: number, endIndexExclusive: number): number[] {
            if (array == null){
                return null;
            }
            if (startIndexInclusive < 0){
                startIndexInclusive = 0;
            }
            if (endIndexExclusive > array.length){
                endIndexExclusive = array.length;
            }
            const newSize: number = endIndexExclusive - startIndexInclusive;
            if (newSize <= 0){
                return ArrayUtils.EMPTY_LONG_ARRAY_$LI$();
            }
            const subarray: number[] = (s => { let a=[]; while(s-->0) a.push(0); return a; })(newSize);
            /* arraycopy */((srcPts, srcOff, dstPts, dstOff, size) => { if(srcPts !== dstPts || dstOff >= srcOff + size) { while (--size >= 0) dstPts[dstOff++] = srcPts[srcOff++];} else { let tmp = srcPts.slice(srcOff, srcOff + size); for (let i = 0; i < size; i++) dstPts[dstOff++] = tmp[i]; }})(array, startIndexInclusive, subarray, 0, newSize);
            return subarray;
        }

        public static subarray$int_A$int$int(array: number[], startIndexInclusive: number, endIndexExclusive: number): number[] {
            if (array == null){
                return null;
            }
            if (startIndexInclusive < 0){
                startIndexInclusive = 0;
            }
            if (endIndexExclusive > array.length){
                endIndexExclusive = array.length;
            }
            const newSize: number = endIndexExclusive - startIndexInclusive;
            if (newSize <= 0){
                return ArrayUtils.EMPTY_INT_ARRAY_$LI$();
            }
            const subarray: number[] = (s => { let a=[]; while(s-->0) a.push(0); return a; })(newSize);
            /* arraycopy */((srcPts, srcOff, dstPts, dstOff, size) => { if(srcPts !== dstPts || dstOff >= srcOff + size) { while (--size >= 0) dstPts[dstOff++] = srcPts[srcOff++];} else { let tmp = srcPts.slice(srcOff, srcOff + size); for (let i = 0; i < size; i++) dstPts[dstOff++] = tmp[i]; }})(array, startIndexInclusive, subarray, 0, newSize);
            return subarray;
        }

        public static subarray$short_A$int$int(array: number[], startIndexInclusive: number, endIndexExclusive: number): number[] {
            if (array == null){
                return null;
            }
            if (startIndexInclusive < 0){
                startIndexInclusive = 0;
            }
            if (endIndexExclusive > array.length){
                endIndexExclusive = array.length;
            }
            const newSize: number = endIndexExclusive - startIndexInclusive;
            if (newSize <= 0){
                return ArrayUtils.EMPTY_SHORT_ARRAY_$LI$();
            }
            const subarray: number[] = (s => { let a=[]; while(s-->0) a.push(0); return a; })(newSize);
            /* arraycopy */((srcPts, srcOff, dstPts, dstOff, size) => { if(srcPts !== dstPts || dstOff >= srcOff + size) { while (--size >= 0) dstPts[dstOff++] = srcPts[srcOff++];} else { let tmp = srcPts.slice(srcOff, srcOff + size); for (let i = 0; i < size; i++) dstPts[dstOff++] = tmp[i]; }})(array, startIndexInclusive, subarray, 0, newSize);
            return subarray;
        }

        public static subarray$char_A$int$int(array: string[], startIndexInclusive: number, endIndexExclusive: number): string[] {
            if (array == null){
                return null;
            }
            if (startIndexInclusive < 0){
                startIndexInclusive = 0;
            }
            if (endIndexExclusive > array.length){
                endIndexExclusive = array.length;
            }
            const newSize: number = endIndexExclusive - startIndexInclusive;
            if (newSize <= 0){
                return ArrayUtils.EMPTY_CHAR_ARRAY_$LI$();
            }
            const subarray: string[] = (s => { let a=[]; while(s-->0) a.push(null); return a; })(newSize);
            /* arraycopy */((srcPts, srcOff, dstPts, dstOff, size) => { if(srcPts !== dstPts || dstOff >= srcOff + size) { while (--size >= 0) dstPts[dstOff++] = srcPts[srcOff++];} else { let tmp = srcPts.slice(srcOff, srcOff + size); for (let i = 0; i < size; i++) dstPts[dstOff++] = tmp[i]; }})(array, startIndexInclusive, subarray, 0, newSize);
            return subarray;
        }

        public static subarray$byte_A$int$int(array: number[], startIndexInclusive: number, endIndexExclusive: number): number[] {
            if (array == null){
                return null;
            }
            if (startIndexInclusive < 0){
                startIndexInclusive = 0;
            }
            if (endIndexExclusive > array.length){
                endIndexExclusive = array.length;
            }
            const newSize: number = endIndexExclusive - startIndexInclusive;
            if (newSize <= 0){
                return ArrayUtils.EMPTY_BYTE_ARRAY_$LI$();
            }
            const subarray: number[] = (s => { let a=[]; while(s-->0) a.push(0); return a; })(newSize);
            /* arraycopy */((srcPts, srcOff, dstPts, dstOff, size) => { if(srcPts !== dstPts || dstOff >= srcOff + size) { while (--size >= 0) dstPts[dstOff++] = srcPts[srcOff++];} else { let tmp = srcPts.slice(srcOff, srcOff + size); for (let i = 0; i < size; i++) dstPts[dstOff++] = tmp[i]; }})(array, startIndexInclusive, subarray, 0, newSize);
            return subarray;
        }

        public static subarray$double_A$int$int(array: number[], startIndexInclusive: number, endIndexExclusive: number): number[] {
            if (array == null){
                return null;
            }
            if (startIndexInclusive < 0){
                startIndexInclusive = 0;
            }
            if (endIndexExclusive > array.length){
                endIndexExclusive = array.length;
            }
            const newSize: number = endIndexExclusive - startIndexInclusive;
            if (newSize <= 0){
                return ArrayUtils.EMPTY_DOUBLE_ARRAY_$LI$();
            }
            const subarray: number[] = (s => { let a=[]; while(s-->0) a.push(0); return a; })(newSize);
            /* arraycopy */((srcPts, srcOff, dstPts, dstOff, size) => { if(srcPts !== dstPts || dstOff >= srcOff + size) { while (--size >= 0) dstPts[dstOff++] = srcPts[srcOff++];} else { let tmp = srcPts.slice(srcOff, srcOff + size); for (let i = 0; i < size; i++) dstPts[dstOff++] = tmp[i]; }})(array, startIndexInclusive, subarray, 0, newSize);
            return subarray;
        }

        public static subarray$float_A$int$int(array: number[], startIndexInclusive: number, endIndexExclusive: number): number[] {
            if (array == null){
                return null;
            }
            if (startIndexInclusive < 0){
                startIndexInclusive = 0;
            }
            if (endIndexExclusive > array.length){
                endIndexExclusive = array.length;
            }
            const newSize: number = endIndexExclusive - startIndexInclusive;
            if (newSize <= 0){
                return ArrayUtils.EMPTY_FLOAT_ARRAY_$LI$();
            }
            const subarray: number[] = (s => { let a=[]; while(s-->0) a.push(0); return a; })(newSize);
            /* arraycopy */((srcPts, srcOff, dstPts, dstOff, size) => { if(srcPts !== dstPts || dstOff >= srcOff + size) { while (--size >= 0) dstPts[dstOff++] = srcPts[srcOff++];} else { let tmp = srcPts.slice(srcOff, srcOff + size); for (let i = 0; i < size; i++) dstPts[dstOff++] = tmp[i]; }})(array, startIndexInclusive, subarray, 0, newSize);
            return subarray;
        }

        public static subarray$boolean_A$int$int(array: boolean[], startIndexInclusive: number, endIndexExclusive: number): boolean[] {
            if (array == null){
                return null;
            }
            if (startIndexInclusive < 0){
                startIndexInclusive = 0;
            }
            if (endIndexExclusive > array.length){
                endIndexExclusive = array.length;
            }
            const newSize: number = endIndexExclusive - startIndexInclusive;
            if (newSize <= 0){
                return ArrayUtils.EMPTY_BOOLEAN_ARRAY_$LI$();
            }
            const subarray: boolean[] = (s => { let a=[]; while(s-->0) a.push(false); return a; })(newSize);
            /* arraycopy */((srcPts, srcOff, dstPts, dstOff, size) => { if(srcPts !== dstPts || dstOff >= srcOff + size) { while (--size >= 0) dstPts[dstOff++] = srcPts[srcOff++];} else { let tmp = srcPts.slice(srcOff, srcOff + size); for (let i = 0; i < size; i++) dstPts[dstOff++] = tmp[i]; }})(array, startIndexInclusive, subarray, 0, newSize);
            return subarray;
        }

        public static isSameLength$java_lang_Object_A$java_lang_Object_A(array1: any[], array2: any[]): boolean {
            if ((array1 == null && array2 != null && array2.length > 0) || (array2 == null && array1 != null && array1.length > 0) || (array1 != null && array2 != null && array1.length !== array2.length)){
                return false;
            }
            return true;
        }

        /**
         * <p>Checks whether two arrays are the same length, treating
         * <code>null</code> arrays as length <code>0</code>.
         * 
         * <p>Any multi-dimensional aspects of the arrays are ignored.</p>
         * 
         * @param {java.lang.Object[]} array1 the first array, may be <code>null</code>
         * @param {java.lang.Object[]} array2 the second array, may be <code>null</code>
         * @return {boolean} <code>true</code> if length of arrays matches, treating
         * <code>null</code> as an empty array
         */
        public static isSameLength(array1?: any, array2?: any): any {
            if (((array1 != null && array1 instanceof <any>Array && (array1.length == 0 || array1[0] == null ||(array1[0] != null))) || array1 === null) && ((array2 != null && array2 instanceof <any>Array && (array2.length == 0 || array2[0] == null ||(array2[0] != null))) || array2 === null)) {
                return <any>org.openprovenance.apache.commons.lang.ArrayUtils.isSameLength$java_lang_Object_A$java_lang_Object_A(array1, array2);
            } else if (((array1 != null && array1 instanceof <any>Array && (array1.length == 0 || array1[0] == null ||(typeof array1[0] === 'number'))) || array1 === null) && ((array2 != null && array2 instanceof <any>Array && (array2.length == 0 || array2[0] == null ||(typeof array2[0] === 'number'))) || array2 === null)) {
                return <any>org.openprovenance.apache.commons.lang.ArrayUtils.isSameLength$long_A$long_A(array1, array2);
            } else if (((array1 != null && array1 instanceof <any>Array && (array1.length == 0 || array1[0] == null ||(typeof array1[0] === 'number'))) || array1 === null) && ((array2 != null && array2 instanceof <any>Array && (array2.length == 0 || array2[0] == null ||(typeof array2[0] === 'number'))) || array2 === null)) {
                return <any>org.openprovenance.apache.commons.lang.ArrayUtils.isSameLength$int_A$int_A(array1, array2);
            } else if (((array1 != null && array1 instanceof <any>Array && (array1.length == 0 || array1[0] == null ||(typeof array1[0] === 'number'))) || array1 === null) && ((array2 != null && array2 instanceof <any>Array && (array2.length == 0 || array2[0] == null ||(typeof array2[0] === 'number'))) || array2 === null)) {
                return <any>org.openprovenance.apache.commons.lang.ArrayUtils.isSameLength$short_A$short_A(array1, array2);
            } else if (((array1 != null && array1 instanceof <any>Array && (array1.length == 0 || array1[0] == null ||(typeof array1[0] === 'string'))) || array1 === null) && ((array2 != null && array2 instanceof <any>Array && (array2.length == 0 || array2[0] == null ||(typeof array2[0] === 'string'))) || array2 === null)) {
                return <any>org.openprovenance.apache.commons.lang.ArrayUtils.isSameLength$char_A$char_A(array1, array2);
            } else if (((array1 != null && array1 instanceof <any>Array && (array1.length == 0 || array1[0] == null ||(typeof array1[0] === 'number'))) || array1 === null) && ((array2 != null && array2 instanceof <any>Array && (array2.length == 0 || array2[0] == null ||(typeof array2[0] === 'number'))) || array2 === null)) {
                return <any>org.openprovenance.apache.commons.lang.ArrayUtils.isSameLength$byte_A$byte_A(array1, array2);
            } else if (((array1 != null && array1 instanceof <any>Array && (array1.length == 0 || array1[0] == null ||(typeof array1[0] === 'number'))) || array1 === null) && ((array2 != null && array2 instanceof <any>Array && (array2.length == 0 || array2[0] == null ||(typeof array2[0] === 'number'))) || array2 === null)) {
                return <any>org.openprovenance.apache.commons.lang.ArrayUtils.isSameLength$double_A$double_A(array1, array2);
            } else if (((array1 != null && array1 instanceof <any>Array && (array1.length == 0 || array1[0] == null ||(typeof array1[0] === 'number'))) || array1 === null) && ((array2 != null && array2 instanceof <any>Array && (array2.length == 0 || array2[0] == null ||(typeof array2[0] === 'number'))) || array2 === null)) {
                return <any>org.openprovenance.apache.commons.lang.ArrayUtils.isSameLength$float_A$float_A(array1, array2);
            } else if (((array1 != null && array1 instanceof <any>Array && (array1.length == 0 || array1[0] == null ||(typeof array1[0] === 'boolean'))) || array1 === null) && ((array2 != null && array2 instanceof <any>Array && (array2.length == 0 || array2[0] == null ||(typeof array2[0] === 'boolean'))) || array2 === null)) {
                return <any>org.openprovenance.apache.commons.lang.ArrayUtils.isSameLength$boolean_A$boolean_A(array1, array2);
            } else throw new Error('invalid overload');
        }

        public static isSameLength$long_A$long_A(array1: number[], array2: number[]): boolean {
            if ((array1 == null && array2 != null && array2.length > 0) || (array2 == null && array1 != null && array1.length > 0) || (array1 != null && array2 != null && array1.length !== array2.length)){
                return false;
            }
            return true;
        }

        public static isSameLength$int_A$int_A(array1: number[], array2: number[]): boolean {
            if ((array1 == null && array2 != null && array2.length > 0) || (array2 == null && array1 != null && array1.length > 0) || (array1 != null && array2 != null && array1.length !== array2.length)){
                return false;
            }
            return true;
        }

        public static isSameLength$short_A$short_A(array1: number[], array2: number[]): boolean {
            if ((array1 == null && array2 != null && array2.length > 0) || (array2 == null && array1 != null && array1.length > 0) || (array1 != null && array2 != null && array1.length !== array2.length)){
                return false;
            }
            return true;
        }

        public static isSameLength$char_A$char_A(array1: string[], array2: string[]): boolean {
            if ((array1 == null && array2 != null && array2.length > 0) || (array2 == null && array1 != null && array1.length > 0) || (array1 != null && array2 != null && array1.length !== array2.length)){
                return false;
            }
            return true;
        }

        public static isSameLength$byte_A$byte_A(array1: number[], array2: number[]): boolean {
            if ((array1 == null && array2 != null && array2.length > 0) || (array2 == null && array1 != null && array1.length > 0) || (array1 != null && array2 != null && array1.length !== array2.length)){
                return false;
            }
            return true;
        }

        public static isSameLength$double_A$double_A(array1: number[], array2: number[]): boolean {
            if ((array1 == null && array2 != null && array2.length > 0) || (array2 == null && array1 != null && array1.length > 0) || (array1 != null && array2 != null && array1.length !== array2.length)){
                return false;
            }
            return true;
        }

        public static isSameLength$float_A$float_A(array1: number[], array2: number[]): boolean {
            if ((array1 == null && array2 != null && array2.length > 0) || (array2 == null && array1 != null && array1.length > 0) || (array1 != null && array2 != null && array1.length !== array2.length)){
                return false;
            }
            return true;
        }

        public static isSameLength$boolean_A$boolean_A(array1: boolean[], array2: boolean[]): boolean {
            if ((array1 == null && array2 != null && array2.length > 0) || (array2 == null && array1 != null && array1.length > 0) || (array1 != null && array2 != null && array1.length !== array2.length)){
                return false;
            }
            return true;
        }

        /**
         * <p>Returns the length of the specified array.
         * This method can deal with <code>Object</code> arrays and with primitive arrays.</p>
         * 
         * <p>If the input array is <code>null</code>, <code>0</code> is returned.</p>
         * 
         * <pre>
         * ArrayUtils.getLength(null)            = 0
         * ArrayUtils.getLength([])              = 0
         * ArrayUtils.getLength([null])          = 1
         * ArrayUtils.getLength([true, false])   = 2
         * ArrayUtils.getLength([1, 2, 3])       = 3
         * ArrayUtils.getLength(["a", "b", "c"]) = 3
         * </pre>
         * 
         * @param {*} array  the array to retrieve the length from, may be null
         * @return {number} The length of the array, or <code>0</code> if the array is <code>null</code>
         * @throws IllegalArgumentException if the object arguement is not an array.
         * @since 2.1
         */
        public static getLength(array: any): number {
            if (array == null){
                return 0;
            }
            return /* getLength */array.length;
        }

        /**
         * <p>Checks whether two arrays are the same type taking into account
         * multi-dimensional arrays.</p>
         * 
         * @param {*} array1 the first array, must not be <code>null</code>
         * @param {*} array2 the second array, must not be <code>null</code>
         * @return {boolean} <code>true</code> if type of arrays matches
         * @throws IllegalArgumentException if either array is <code>null</code>
         */
        public static isSameType(array1: any, array2: any): boolean {
            if (array1 == null || array2 == null){
                throw Object.defineProperty(new Error("The Array must not be null"), '__classes', { configurable: true, value: ['java.lang.Throwable','java.lang.Object','java.lang.RuntimeException','java.lang.IllegalArgumentException','java.lang.Exception'] });
            }
            return /* getName */(c => typeof c === 'string' ? c : c["__class"] ? c["__class"] : c["name"])((<any>array1.constructor)) === /* getName */(c => typeof c === 'string' ? c : c["__class"] ? c["__class"] : c["name"])((<any>array2.constructor));
        }

        public static reverse$java_lang_Object_A(array: any[]) {
            if (array == null){
                return;
            }
            let i: number = 0;
            let j: number = array.length - 1;
            let tmp: any;
            while((j > i)) {{
                tmp = array[j];
                array[j] = array[i];
                array[i] = tmp;
                j--;
                i++;
            }};
        }

        /**
         * <p>Reverses the order of the given array.</p>
         * 
         * <p>There is no special handling for multi-dimensional arrays.</p>
         * 
         * <p>This method does nothing for a <code>null</code> input array.</p>
         * 
         * @param {java.lang.Object[]} array  the array to reverse, may be <code>null</code>
         */
        public static reverse(array?: any) {
            if (((array != null && array instanceof <any>Array && (array.length == 0 || array[0] == null ||(array[0] != null))) || array === null)) {
                return <any>org.openprovenance.apache.commons.lang.ArrayUtils.reverse$java_lang_Object_A(array);
            } else if (((array != null && array instanceof <any>Array && (array.length == 0 || array[0] == null ||(typeof array[0] === 'number'))) || array === null)) {
                return <any>org.openprovenance.apache.commons.lang.ArrayUtils.reverse$long_A(array);
            } else if (((array != null && array instanceof <any>Array && (array.length == 0 || array[0] == null ||(typeof array[0] === 'number'))) || array === null)) {
                return <any>org.openprovenance.apache.commons.lang.ArrayUtils.reverse$int_A(array);
            } else if (((array != null && array instanceof <any>Array && (array.length == 0 || array[0] == null ||(typeof array[0] === 'number'))) || array === null)) {
                return <any>org.openprovenance.apache.commons.lang.ArrayUtils.reverse$short_A(array);
            } else if (((array != null && array instanceof <any>Array && (array.length == 0 || array[0] == null ||(typeof array[0] === 'string'))) || array === null)) {
                return <any>org.openprovenance.apache.commons.lang.ArrayUtils.reverse$char_A(array);
            } else if (((array != null && array instanceof <any>Array && (array.length == 0 || array[0] == null ||(typeof array[0] === 'number'))) || array === null)) {
                return <any>org.openprovenance.apache.commons.lang.ArrayUtils.reverse$byte_A(array);
            } else if (((array != null && array instanceof <any>Array && (array.length == 0 || array[0] == null ||(typeof array[0] === 'number'))) || array === null)) {
                return <any>org.openprovenance.apache.commons.lang.ArrayUtils.reverse$double_A(array);
            } else if (((array != null && array instanceof <any>Array && (array.length == 0 || array[0] == null ||(typeof array[0] === 'number'))) || array === null)) {
                return <any>org.openprovenance.apache.commons.lang.ArrayUtils.reverse$float_A(array);
            } else if (((array != null && array instanceof <any>Array && (array.length == 0 || array[0] == null ||(typeof array[0] === 'boolean'))) || array === null)) {
                return <any>org.openprovenance.apache.commons.lang.ArrayUtils.reverse$boolean_A(array);
            } else throw new Error('invalid overload');
        }

        public static reverse$long_A(array: number[]) {
            if (array == null){
                return;
            }
            let i: number = 0;
            let j: number = array.length - 1;
            let tmp: number;
            while((j > i)) {{
                tmp = array[j];
                array[j] = array[i];
                array[i] = tmp;
                j--;
                i++;
            }};
        }

        public static reverse$int_A(array: number[]) {
            if (array == null){
                return;
            }
            let i: number = 0;
            let j: number = array.length - 1;
            let tmp: number;
            while((j > i)) {{
                tmp = array[j];
                array[j] = array[i];
                array[i] = tmp;
                j--;
                i++;
            }};
        }

        public static reverse$short_A(array: number[]) {
            if (array == null){
                return;
            }
            let i: number = 0;
            let j: number = array.length - 1;
            let tmp: number;
            while((j > i)) {{
                tmp = array[j];
                array[j] = array[i];
                array[i] = tmp;
                j--;
                i++;
            }};
        }

        public static reverse$char_A(array: string[]) {
            if (array == null){
                return;
            }
            let i: number = 0;
            let j: number = array.length - 1;
            let tmp: string;
            while((j > i)) {{
                tmp = array[j];
                array[j] = array[i];
                array[i] = tmp;
                j--;
                i++;
            }};
        }

        public static reverse$byte_A(array: number[]) {
            if (array == null){
                return;
            }
            let i: number = 0;
            let j: number = array.length - 1;
            let tmp: number;
            while((j > i)) {{
                tmp = array[j];
                array[j] = array[i];
                array[i] = tmp;
                j--;
                i++;
            }};
        }

        public static reverse$double_A(array: number[]) {
            if (array == null){
                return;
            }
            let i: number = 0;
            let j: number = array.length - 1;
            let tmp: number;
            while((j > i)) {{
                tmp = array[j];
                array[j] = array[i];
                array[i] = tmp;
                j--;
                i++;
            }};
        }

        public static reverse$float_A(array: number[]) {
            if (array == null){
                return;
            }
            let i: number = 0;
            let j: number = array.length - 1;
            let tmp: number;
            while((j > i)) {{
                tmp = array[j];
                array[j] = array[i];
                array[i] = tmp;
                j--;
                i++;
            }};
        }

        public static reverse$boolean_A(array: boolean[]) {
            if (array == null){
                return;
            }
            let i: number = 0;
            let j: number = array.length - 1;
            let tmp: boolean;
            while((j > i)) {{
                tmp = array[j];
                array[j] = array[i];
                array[i] = tmp;
                j--;
                i++;
            }};
        }

        public static indexOf$java_lang_Object_A$java_lang_Object(array: any[], objectToFind: any): number {
            return ArrayUtils.indexOf$java_lang_Object_A$java_lang_Object$int(array, objectToFind, 0);
        }

        public static indexOf$java_lang_Object_A$java_lang_Object$int(array: any[], objectToFind: any, startIndex: number): number {
            if (array == null){
                return ArrayUtils.INDEX_NOT_FOUND;
            }
            if (startIndex < 0){
                startIndex = 0;
            }
            if (objectToFind == null){
                for(let i: number = startIndex; i < array.length; i++) {{
                    if (array[i] == null){
                        return i;
                    }
                };}
            } else if (/* isInstance */((c:any,o:any) => { if(typeof c === 'string') return (o.constructor && o.constructor["__interfaces"] && o.constructor["__interfaces"].indexOf(c) >= 0) || (o["__interfaces"] && o["__interfaces"].indexOf(c) >= 0); else if(typeof c === 'function') return (o instanceof c) || (o.constructor && o.constructor === c); })((<any>array.constructor).getComponentType(), objectToFind)){
                for(let i: number = startIndex; i < array.length; i++) {{
                    if (/* equals */(<any>((o1: any, o2: any) => o1 && o1.equals ? o1.equals(o2) : o1 === o2)(objectToFind,array[i]))){
                        return i;
                    }
                };}
            }
            return ArrayUtils.INDEX_NOT_FOUND;
        }

        public static lastIndexOf$java_lang_Object_A$java_lang_Object(array: any[], objectToFind: any): number {
            return ArrayUtils.lastIndexOf$java_lang_Object_A$java_lang_Object$int(array, objectToFind, 2147483647);
        }

        public static lastIndexOf$java_lang_Object_A$java_lang_Object$int(array: any[], objectToFind: any, startIndex: number): number {
            if (array == null){
                return ArrayUtils.INDEX_NOT_FOUND;
            }
            if (startIndex < 0){
                return ArrayUtils.INDEX_NOT_FOUND;
            } else if (startIndex >= array.length){
                startIndex = array.length - 1;
            }
            if (objectToFind == null){
                for(let i: number = startIndex; i >= 0; i--) {{
                    if (array[i] == null){
                        return i;
                    }
                };}
            } else if (/* isInstance */((c:any,o:any) => { if(typeof c === 'string') return (o.constructor && o.constructor["__interfaces"] && o.constructor["__interfaces"].indexOf(c) >= 0) || (o["__interfaces"] && o["__interfaces"].indexOf(c) >= 0); else if(typeof c === 'function') return (o instanceof c) || (o.constructor && o.constructor === c); })((<any>array.constructor).getComponentType(), objectToFind)){
                for(let i: number = startIndex; i >= 0; i--) {{
                    if (/* equals */(<any>((o1: any, o2: any) => o1 && o1.equals ? o1.equals(o2) : o1 === o2)(objectToFind,array[i]))){
                        return i;
                    }
                };}
            }
            return ArrayUtils.INDEX_NOT_FOUND;
        }

        public static contains$java_lang_Object_A$java_lang_Object(array: any[], objectToFind: any): boolean {
            return ArrayUtils.indexOf$java_lang_Object_A$java_lang_Object(array, objectToFind) !== ArrayUtils.INDEX_NOT_FOUND;
        }

        public static indexOf$long_A$long(array: number[], valueToFind: number): number {
            return ArrayUtils.indexOf$long_A$long$int(array, valueToFind, 0);
        }

        public static indexOf$long_A$long$int(array: number[], valueToFind: number, startIndex: number): number {
            if (array == null){
                return ArrayUtils.INDEX_NOT_FOUND;
            }
            if (startIndex < 0){
                startIndex = 0;
            }
            for(let i: number = startIndex; i < array.length; i++) {{
                if (valueToFind === array[i]){
                    return i;
                }
            };}
            return ArrayUtils.INDEX_NOT_FOUND;
        }

        public static lastIndexOf$long_A$long(array: number[], valueToFind: number): number {
            return ArrayUtils.lastIndexOf$long_A$long$int(array, valueToFind, 2147483647);
        }

        public static lastIndexOf$long_A$long$int(array: number[], valueToFind: number, startIndex: number): number {
            if (array == null){
                return ArrayUtils.INDEX_NOT_FOUND;
            }
            if (startIndex < 0){
                return ArrayUtils.INDEX_NOT_FOUND;
            } else if (startIndex >= array.length){
                startIndex = array.length - 1;
            }
            for(let i: number = startIndex; i >= 0; i--) {{
                if (valueToFind === array[i]){
                    return i;
                }
            };}
            return ArrayUtils.INDEX_NOT_FOUND;
        }

        public static contains$long_A$long(array: number[], valueToFind: number): boolean {
            return ArrayUtils.indexOf$long_A$long(array, valueToFind) !== ArrayUtils.INDEX_NOT_FOUND;
        }

        public static indexOf$int_A$int(array: number[], valueToFind: number): number {
            return ArrayUtils.indexOf$int_A$int$int(array, valueToFind, 0);
        }

        public static indexOf$int_A$int$int(array: number[], valueToFind: number, startIndex: number): number {
            if (array == null){
                return ArrayUtils.INDEX_NOT_FOUND;
            }
            if (startIndex < 0){
                startIndex = 0;
            }
            for(let i: number = startIndex; i < array.length; i++) {{
                if (valueToFind === array[i]){
                    return i;
                }
            };}
            return ArrayUtils.INDEX_NOT_FOUND;
        }

        public static lastIndexOf$int_A$int(array: number[], valueToFind: number): number {
            return ArrayUtils.lastIndexOf$int_A$int$int(array, valueToFind, 2147483647);
        }

        public static lastIndexOf$int_A$int$int(array: number[], valueToFind: number, startIndex: number): number {
            if (array == null){
                return ArrayUtils.INDEX_NOT_FOUND;
            }
            if (startIndex < 0){
                return ArrayUtils.INDEX_NOT_FOUND;
            } else if (startIndex >= array.length){
                startIndex = array.length - 1;
            }
            for(let i: number = startIndex; i >= 0; i--) {{
                if (valueToFind === array[i]){
                    return i;
                }
            };}
            return ArrayUtils.INDEX_NOT_FOUND;
        }

        public static contains$int_A$int(array: number[], valueToFind: number): boolean {
            return ArrayUtils.indexOf$int_A$int(array, valueToFind) !== ArrayUtils.INDEX_NOT_FOUND;
        }

        public static indexOf$short_A$short(array: number[], valueToFind: number): number {
            return ArrayUtils.indexOf$short_A$short$int(array, valueToFind, 0);
        }

        public static indexOf$short_A$short$int(array: number[], valueToFind: number, startIndex: number): number {
            if (array == null){
                return ArrayUtils.INDEX_NOT_FOUND;
            }
            if (startIndex < 0){
                startIndex = 0;
            }
            for(let i: number = startIndex; i < array.length; i++) {{
                if (valueToFind === array[i]){
                    return i;
                }
            };}
            return ArrayUtils.INDEX_NOT_FOUND;
        }

        public static lastIndexOf$short_A$short(array: number[], valueToFind: number): number {
            return ArrayUtils.lastIndexOf$short_A$short$int(array, valueToFind, 2147483647);
        }

        public static lastIndexOf$short_A$short$int(array: number[], valueToFind: number, startIndex: number): number {
            if (array == null){
                return ArrayUtils.INDEX_NOT_FOUND;
            }
            if (startIndex < 0){
                return ArrayUtils.INDEX_NOT_FOUND;
            } else if (startIndex >= array.length){
                startIndex = array.length - 1;
            }
            for(let i: number = startIndex; i >= 0; i--) {{
                if (valueToFind === array[i]){
                    return i;
                }
            };}
            return ArrayUtils.INDEX_NOT_FOUND;
        }

        public static contains$short_A$short(array: number[], valueToFind: number): boolean {
            return ArrayUtils.indexOf$short_A$short(array, valueToFind) !== ArrayUtils.INDEX_NOT_FOUND;
        }

        public static indexOf$char_A$char(array: string[], valueToFind: string): number {
            return ArrayUtils.indexOf$char_A$char$int(array, valueToFind, 0);
        }

        public static indexOf$char_A$char$int(array: string[], valueToFind: string, startIndex: number): number {
            if (array == null){
                return ArrayUtils.INDEX_NOT_FOUND;
            }
            if (startIndex < 0){
                startIndex = 0;
            }
            for(let i: number = startIndex; i < array.length; i++) {{
                if ((c => c.charCodeAt==null?<any>c:c.charCodeAt(0))(valueToFind) == (c => c.charCodeAt==null?<any>c:c.charCodeAt(0))(array[i])){
                    return i;
                }
            };}
            return ArrayUtils.INDEX_NOT_FOUND;
        }

        public static lastIndexOf$char_A$char(array: string[], valueToFind: string): number {
            return ArrayUtils.lastIndexOf$char_A$char$int(array, valueToFind, 2147483647);
        }

        public static lastIndexOf$char_A$char$int(array: string[], valueToFind: string, startIndex: number): number {
            if (array == null){
                return ArrayUtils.INDEX_NOT_FOUND;
            }
            if (startIndex < 0){
                return ArrayUtils.INDEX_NOT_FOUND;
            } else if (startIndex >= array.length){
                startIndex = array.length - 1;
            }
            for(let i: number = startIndex; i >= 0; i--) {{
                if ((c => c.charCodeAt==null?<any>c:c.charCodeAt(0))(valueToFind) == (c => c.charCodeAt==null?<any>c:c.charCodeAt(0))(array[i])){
                    return i;
                }
            };}
            return ArrayUtils.INDEX_NOT_FOUND;
        }

        public static contains$char_A$char(array: string[], valueToFind: string): boolean {
            return ArrayUtils.indexOf$char_A$char(array, valueToFind) !== ArrayUtils.INDEX_NOT_FOUND;
        }

        public static indexOf$byte_A$byte(array: number[], valueToFind: number): number {
            return ArrayUtils.indexOf$byte_A$byte$int(array, valueToFind, 0);
        }

        public static indexOf$byte_A$byte$int(array: number[], valueToFind: number, startIndex: number): number {
            if (array == null){
                return ArrayUtils.INDEX_NOT_FOUND;
            }
            if (startIndex < 0){
                startIndex = 0;
            }
            for(let i: number = startIndex; i < array.length; i++) {{
                if (valueToFind === array[i]){
                    return i;
                }
            };}
            return ArrayUtils.INDEX_NOT_FOUND;
        }

        public static lastIndexOf$byte_A$byte(array: number[], valueToFind: number): number {
            return ArrayUtils.lastIndexOf$byte_A$byte$int(array, valueToFind, 2147483647);
        }

        public static lastIndexOf$byte_A$byte$int(array: number[], valueToFind: number, startIndex: number): number {
            if (array == null){
                return ArrayUtils.INDEX_NOT_FOUND;
            }
            if (startIndex < 0){
                return ArrayUtils.INDEX_NOT_FOUND;
            } else if (startIndex >= array.length){
                startIndex = array.length - 1;
            }
            for(let i: number = startIndex; i >= 0; i--) {{
                if (valueToFind === array[i]){
                    return i;
                }
            };}
            return ArrayUtils.INDEX_NOT_FOUND;
        }

        public static contains$byte_A$byte(array: number[], valueToFind: number): boolean {
            return ArrayUtils.indexOf$byte_A$byte(array, valueToFind) !== ArrayUtils.INDEX_NOT_FOUND;
        }

        public static indexOf$double_A$double(array: number[], valueToFind: number): number {
            return ArrayUtils.indexOf$double_A$double$int(array, valueToFind, 0);
        }

        public static indexOf$double_A$double$double(array: number[], valueToFind: number, tolerance: number): number {
            return ArrayUtils.indexOf$double_A$double$int$double(array, valueToFind, 0, tolerance);
        }

        public static indexOf$double_A$double$int(array: number[], valueToFind: number, startIndex: number): number {
            if (ArrayUtils.isEmpty$double_A(array)){
                return ArrayUtils.INDEX_NOT_FOUND;
            }
            if (startIndex < 0){
                startIndex = 0;
            }
            for(let i: number = startIndex; i < array.length; i++) {{
                if (valueToFind === array[i]){
                    return i;
                }
            };}
            return ArrayUtils.INDEX_NOT_FOUND;
        }

        public static indexOf$double_A$double$int$double(array: number[], valueToFind: number, startIndex: number, tolerance: number): number {
            if (ArrayUtils.isEmpty$double_A(array)){
                return ArrayUtils.INDEX_NOT_FOUND;
            }
            if (startIndex < 0){
                startIndex = 0;
            }
            const min: number = valueToFind - tolerance;
            const max: number = valueToFind + tolerance;
            for(let i: number = startIndex; i < array.length; i++) {{
                if (array[i] >= min && array[i] <= max){
                    return i;
                }
            };}
            return ArrayUtils.INDEX_NOT_FOUND;
        }

        /**
         * <p>Finds the index of the given value in the array starting at the given index.
         * This method will return the index of the first value which falls between the region
         * defined by valueToFind - tolerance and valueToFind + tolerance.</p>
         * 
         * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>
         * 
         * <p>A negative startIndex is treated as zero. A startIndex larger than the array
         * length will return {@link #INDEX_NOT_FOUND} (<code>-1</code>).</p>
         * 
         * @param {double[]} array  the array to search through for the object, may be <code>null</code>
         * @param {number} valueToFind  the value to find
         * @param {number} startIndex  the index to start searching at
         * @param {number} tolerance tolerance of the search
         * @return {number} the index of the value within the array,
         * {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input
         */
        public static indexOf(array?: any, valueToFind?: any, startIndex?: any, tolerance?: any): any {
            if (((array != null && array instanceof <any>Array && (array.length == 0 || array[0] == null ||(typeof array[0] === 'number'))) || array === null) && ((typeof valueToFind === 'number') || valueToFind === null) && ((typeof startIndex === 'number') || startIndex === null) && ((typeof tolerance === 'number') || tolerance === null)) {
                return <any>org.openprovenance.apache.commons.lang.ArrayUtils.indexOf$double_A$double$int$double(array, valueToFind, startIndex, tolerance);
            } else if (((array != null && array instanceof <any>Array && (array.length == 0 || array[0] == null ||(typeof array[0] === 'number'))) || array === null) && ((typeof valueToFind === 'number') || valueToFind === null) && ((typeof startIndex === 'number') || startIndex === null) && tolerance === undefined) {
                return <any>org.openprovenance.apache.commons.lang.ArrayUtils.indexOf$short_A$short$int(array, valueToFind, startIndex);
            } else if (((array != null && array instanceof <any>Array && (array.length == 0 || array[0] == null ||(typeof array[0] === 'string'))) || array === null) && ((typeof valueToFind === 'string') || valueToFind === null) && ((typeof startIndex === 'number') || startIndex === null) && tolerance === undefined) {
                return <any>org.openprovenance.apache.commons.lang.ArrayUtils.indexOf$char_A$char$int(array, valueToFind, startIndex);
            } else if (((array != null && array instanceof <any>Array && (array.length == 0 || array[0] == null ||(typeof array[0] === 'number'))) || array === null) && ((typeof valueToFind === 'number') || valueToFind === null) && ((typeof startIndex === 'number') || startIndex === null) && tolerance === undefined) {
                return <any>org.openprovenance.apache.commons.lang.ArrayUtils.indexOf$byte_A$byte$int(array, valueToFind, startIndex);
            } else if (((array != null && array instanceof <any>Array && (array.length == 0 || array[0] == null ||(typeof array[0] === 'number'))) || array === null) && ((typeof valueToFind === 'number') || valueToFind === null) && ((typeof startIndex === 'number') || startIndex === null) && tolerance === undefined) {
                return <any>org.openprovenance.apache.commons.lang.ArrayUtils.indexOf$int_A$int$int(array, valueToFind, startIndex);
            } else if (((array != null && array instanceof <any>Array && (array.length == 0 || array[0] == null ||(typeof array[0] === 'number'))) || array === null) && ((typeof valueToFind === 'number') || valueToFind === null) && ((typeof startIndex === 'number') || startIndex === null) && tolerance === undefined) {
                return <any>org.openprovenance.apache.commons.lang.ArrayUtils.indexOf$long_A$long$int(array, valueToFind, startIndex);
            } else if (((array != null && array instanceof <any>Array && (array.length == 0 || array[0] == null ||(typeof array[0] === 'number'))) || array === null) && ((typeof valueToFind === 'number') || valueToFind === null) && ((typeof startIndex === 'number') || startIndex === null) && tolerance === undefined) {
                return <any>org.openprovenance.apache.commons.lang.ArrayUtils.indexOf$float_A$float$int(array, valueToFind, startIndex);
            } else if (((array != null && array instanceof <any>Array && (array.length == 0 || array[0] == null ||(typeof array[0] === 'number'))) || array === null) && ((typeof valueToFind === 'number') || valueToFind === null) && ((typeof startIndex === 'number') || startIndex === null) && tolerance === undefined) {
                return <any>org.openprovenance.apache.commons.lang.ArrayUtils.indexOf$double_A$double$int(array, valueToFind, startIndex);
            } else if (((array != null && array instanceof <any>Array && (array.length == 0 || array[0] == null ||(typeof array[0] === 'boolean'))) || array === null) && ((typeof valueToFind === 'boolean') || valueToFind === null) && ((typeof startIndex === 'number') || startIndex === null) && tolerance === undefined) {
                return <any>org.openprovenance.apache.commons.lang.ArrayUtils.indexOf$boolean_A$boolean$int(array, valueToFind, startIndex);
            } else if (((array != null && array instanceof <any>Array && (array.length == 0 || array[0] == null ||(array[0] != null))) || array === null) && ((valueToFind != null) || valueToFind === null) && ((typeof startIndex === 'number') || startIndex === null) && tolerance === undefined) {
                return <any>org.openprovenance.apache.commons.lang.ArrayUtils.indexOf$java_lang_Object_A$java_lang_Object$int(array, valueToFind, startIndex);
            } else if (((array != null && array instanceof <any>Array && (array.length == 0 || array[0] == null ||(typeof array[0] === 'number'))) || array === null) && ((typeof valueToFind === 'number') || valueToFind === null) && ((typeof startIndex === 'number') || startIndex === null) && tolerance === undefined) {
                return <any>org.openprovenance.apache.commons.lang.ArrayUtils.indexOf$double_A$double$double(array, valueToFind, startIndex);
            } else if (((array != null && array instanceof <any>Array && (array.length == 0 || array[0] == null ||(typeof array[0] === 'number'))) || array === null) && ((typeof valueToFind === 'number') || valueToFind === null) && startIndex === undefined && tolerance === undefined) {
                return <any>org.openprovenance.apache.commons.lang.ArrayUtils.indexOf$byte_A$byte(array, valueToFind);
            } else if (((array != null && array instanceof <any>Array && (array.length == 0 || array[0] == null ||(typeof array[0] === 'number'))) || array === null) && ((typeof valueToFind === 'number') || valueToFind === null) && startIndex === undefined && tolerance === undefined) {
                return <any>org.openprovenance.apache.commons.lang.ArrayUtils.indexOf$short_A$short(array, valueToFind);
            } else if (((array != null && array instanceof <any>Array && (array.length == 0 || array[0] == null ||(typeof array[0] === 'string'))) || array === null) && ((typeof valueToFind === 'string') || valueToFind === null) && startIndex === undefined && tolerance === undefined) {
                return <any>org.openprovenance.apache.commons.lang.ArrayUtils.indexOf$char_A$char(array, valueToFind);
            } else if (((array != null && array instanceof <any>Array && (array.length == 0 || array[0] == null ||(typeof array[0] === 'number'))) || array === null) && ((typeof valueToFind === 'number') || valueToFind === null) && startIndex === undefined && tolerance === undefined) {
                return <any>org.openprovenance.apache.commons.lang.ArrayUtils.indexOf$int_A$int(array, valueToFind);
            } else if (((array != null && array instanceof <any>Array && (array.length == 0 || array[0] == null ||(typeof array[0] === 'number'))) || array === null) && ((typeof valueToFind === 'number') || valueToFind === null) && startIndex === undefined && tolerance === undefined) {
                return <any>org.openprovenance.apache.commons.lang.ArrayUtils.indexOf$long_A$long(array, valueToFind);
            } else if (((array != null && array instanceof <any>Array && (array.length == 0 || array[0] == null ||(typeof array[0] === 'number'))) || array === null) && ((typeof valueToFind === 'number') || valueToFind === null) && startIndex === undefined && tolerance === undefined) {
                return <any>org.openprovenance.apache.commons.lang.ArrayUtils.indexOf$float_A$float(array, valueToFind);
            } else if (((array != null && array instanceof <any>Array && (array.length == 0 || array[0] == null ||(typeof array[0] === 'number'))) || array === null) && ((typeof valueToFind === 'number') || valueToFind === null) && startIndex === undefined && tolerance === undefined) {
                return <any>org.openprovenance.apache.commons.lang.ArrayUtils.indexOf$double_A$double(array, valueToFind);
            } else if (((array != null && array instanceof <any>Array && (array.length == 0 || array[0] == null ||(typeof array[0] === 'boolean'))) || array === null) && ((typeof valueToFind === 'boolean') || valueToFind === null) && startIndex === undefined && tolerance === undefined) {
                return <any>org.openprovenance.apache.commons.lang.ArrayUtils.indexOf$boolean_A$boolean(array, valueToFind);
            } else if (((array != null && array instanceof <any>Array && (array.length == 0 || array[0] == null ||(array[0] != null))) || array === null) && ((valueToFind != null) || valueToFind === null) && startIndex === undefined && tolerance === undefined) {
                return <any>org.openprovenance.apache.commons.lang.ArrayUtils.indexOf$java_lang_Object_A$java_lang_Object(array, valueToFind);
            } else throw new Error('invalid overload');
        }

        public static lastIndexOf$double_A$double(array: number[], valueToFind: number): number {
            return ArrayUtils.lastIndexOf$double_A$double$int(array, valueToFind, 2147483647);
        }

        public static lastIndexOf$double_A$double$double(array: number[], valueToFind: number, tolerance: number): number {
            return ArrayUtils.lastIndexOf$double_A$double$int$double(array, valueToFind, 2147483647, tolerance);
        }

        public static lastIndexOf$double_A$double$int(array: number[], valueToFind: number, startIndex: number): number {
            if (ArrayUtils.isEmpty$double_A(array)){
                return ArrayUtils.INDEX_NOT_FOUND;
            }
            if (startIndex < 0){
                return ArrayUtils.INDEX_NOT_FOUND;
            } else if (startIndex >= array.length){
                startIndex = array.length - 1;
            }
            for(let i: number = startIndex; i >= 0; i--) {{
                if (valueToFind === array[i]){
                    return i;
                }
            };}
            return ArrayUtils.INDEX_NOT_FOUND;
        }

        public static lastIndexOf$double_A$double$int$double(array: number[], valueToFind: number, startIndex: number, tolerance: number): number {
            if (ArrayUtils.isEmpty$double_A(array)){
                return ArrayUtils.INDEX_NOT_FOUND;
            }
            if (startIndex < 0){
                return ArrayUtils.INDEX_NOT_FOUND;
            } else if (startIndex >= array.length){
                startIndex = array.length - 1;
            }
            const min: number = valueToFind - tolerance;
            const max: number = valueToFind + tolerance;
            for(let i: number = startIndex; i >= 0; i--) {{
                if (array[i] >= min && array[i] <= max){
                    return i;
                }
            };}
            return ArrayUtils.INDEX_NOT_FOUND;
        }

        /**
         * <p>Finds the last index of the given value in the array starting at the given index.
         * This method will return the index of the last value which falls between the region
         * defined by valueToFind - tolerance and valueToFind + tolerance.</p>
         * 
         * <p>This method returns {@link #INDEX_NOT_FOUND} (<code>-1</code>) for a <code>null</code> input array.</p>
         * 
         * <p>A negative startIndex will return {@link #INDEX_NOT_FOUND} (<code>-1</code>). A startIndex larger than the
         * array length will search from the end of the array.</p>
         * 
         * @param {double[]} array  the array to traverse for looking for the object, may be <code>null</code>
         * @param {number} valueToFind  the value to find
         * @param {number} startIndex  the start index to travers backwards from
         * @param {number} tolerance  search for value within plus/minus this amount
         * @return {number} the last index of the value within the array,
         * {@link #INDEX_NOT_FOUND} (<code>-1</code>) if not found or <code>null</code> array input
         */
        public static lastIndexOf(array?: any, valueToFind?: any, startIndex?: any, tolerance?: any): any {
            if (((array != null && array instanceof <any>Array && (array.length == 0 || array[0] == null ||(typeof array[0] === 'number'))) || array === null) && ((typeof valueToFind === 'number') || valueToFind === null) && ((typeof startIndex === 'number') || startIndex === null) && ((typeof tolerance === 'number') || tolerance === null)) {
                return <any>org.openprovenance.apache.commons.lang.ArrayUtils.lastIndexOf$double_A$double$int$double(array, valueToFind, startIndex, tolerance);
            } else if (((array != null && array instanceof <any>Array && (array.length == 0 || array[0] == null ||(typeof array[0] === 'number'))) || array === null) && ((typeof valueToFind === 'number') || valueToFind === null) && ((typeof startIndex === 'number') || startIndex === null) && tolerance === undefined) {
                return <any>org.openprovenance.apache.commons.lang.ArrayUtils.lastIndexOf$short_A$short$int(array, valueToFind, startIndex);
            } else if (((array != null && array instanceof <any>Array && (array.length == 0 || array[0] == null ||(typeof array[0] === 'string'))) || array === null) && ((typeof valueToFind === 'string') || valueToFind === null) && ((typeof startIndex === 'number') || startIndex === null) && tolerance === undefined) {
                return <any>org.openprovenance.apache.commons.lang.ArrayUtils.lastIndexOf$char_A$char$int(array, valueToFind, startIndex);
            } else if (((array != null && array instanceof <any>Array && (array.length == 0 || array[0] == null ||(typeof array[0] === 'number'))) || array === null) && ((typeof valueToFind === 'number') || valueToFind === null) && ((typeof startIndex === 'number') || startIndex === null) && tolerance === undefined) {
                return <any>org.openprovenance.apache.commons.lang.ArrayUtils.lastIndexOf$byte_A$byte$int(array, valueToFind, startIndex);
            } else if (((array != null && array instanceof <any>Array && (array.length == 0 || array[0] == null ||(typeof array[0] === 'number'))) || array === null) && ((typeof valueToFind === 'number') || valueToFind === null) && ((typeof startIndex === 'number') || startIndex === null) && tolerance === undefined) {
                return <any>org.openprovenance.apache.commons.lang.ArrayUtils.lastIndexOf$int_A$int$int(array, valueToFind, startIndex);
            } else if (((array != null && array instanceof <any>Array && (array.length == 0 || array[0] == null ||(typeof array[0] === 'number'))) || array === null) && ((typeof valueToFind === 'number') || valueToFind === null) && ((typeof startIndex === 'number') || startIndex === null) && tolerance === undefined) {
                return <any>org.openprovenance.apache.commons.lang.ArrayUtils.lastIndexOf$long_A$long$int(array, valueToFind, startIndex);
            } else if (((array != null && array instanceof <any>Array && (array.length == 0 || array[0] == null ||(typeof array[0] === 'number'))) || array === null) && ((typeof valueToFind === 'number') || valueToFind === null) && ((typeof startIndex === 'number') || startIndex === null) && tolerance === undefined) {
                return <any>org.openprovenance.apache.commons.lang.ArrayUtils.lastIndexOf$float_A$float$int(array, valueToFind, startIndex);
            } else if (((array != null && array instanceof <any>Array && (array.length == 0 || array[0] == null ||(typeof array[0] === 'number'))) || array === null) && ((typeof valueToFind === 'number') || valueToFind === null) && ((typeof startIndex === 'number') || startIndex === null) && tolerance === undefined) {
                return <any>org.openprovenance.apache.commons.lang.ArrayUtils.lastIndexOf$double_A$double$int(array, valueToFind, startIndex);
            } else if (((array != null && array instanceof <any>Array && (array.length == 0 || array[0] == null ||(typeof array[0] === 'boolean'))) || array === null) && ((typeof valueToFind === 'boolean') || valueToFind === null) && ((typeof startIndex === 'number') || startIndex === null) && tolerance === undefined) {
                return <any>org.openprovenance.apache.commons.lang.ArrayUtils.lastIndexOf$boolean_A$boolean$int(array, valueToFind, startIndex);
            } else if (((array != null && array instanceof <any>Array && (array.length == 0 || array[0] == null ||(array[0] != null))) || array === null) && ((valueToFind != null) || valueToFind === null) && ((typeof startIndex === 'number') || startIndex === null) && tolerance === undefined) {
                return <any>org.openprovenance.apache.commons.lang.ArrayUtils.lastIndexOf$java_lang_Object_A$java_lang_Object$int(array, valueToFind, startIndex);
            } else if (((array != null && array instanceof <any>Array && (array.length == 0 || array[0] == null ||(typeof array[0] === 'number'))) || array === null) && ((typeof valueToFind === 'number') || valueToFind === null) && ((typeof startIndex === 'number') || startIndex === null) && tolerance === undefined) {
                return <any>org.openprovenance.apache.commons.lang.ArrayUtils.lastIndexOf$double_A$double$double(array, valueToFind, startIndex);
            } else if (((array != null && array instanceof <any>Array && (array.length == 0 || array[0] == null ||(typeof array[0] === 'number'))) || array === null) && ((typeof valueToFind === 'number') || valueToFind === null) && startIndex === undefined && tolerance === undefined) {
                return <any>org.openprovenance.apache.commons.lang.ArrayUtils.lastIndexOf$byte_A$byte(array, valueToFind);
            } else if (((array != null && array instanceof <any>Array && (array.length == 0 || array[0] == null ||(typeof array[0] === 'number'))) || array === null) && ((typeof valueToFind === 'number') || valueToFind === null) && startIndex === undefined && tolerance === undefined) {
                return <any>org.openprovenance.apache.commons.lang.ArrayUtils.lastIndexOf$short_A$short(array, valueToFind);
            } else if (((array != null && array instanceof <any>Array && (array.length == 0 || array[0] == null ||(typeof array[0] === 'string'))) || array === null) && ((typeof valueToFind === 'string') || valueToFind === null) && startIndex === undefined && tolerance === undefined) {
                return <any>org.openprovenance.apache.commons.lang.ArrayUtils.lastIndexOf$char_A$char(array, valueToFind);
            } else if (((array != null && array instanceof <any>Array && (array.length == 0 || array[0] == null ||(typeof array[0] === 'number'))) || array === null) && ((typeof valueToFind === 'number') || valueToFind === null) && startIndex === undefined && tolerance === undefined) {
                return <any>org.openprovenance.apache.commons.lang.ArrayUtils.lastIndexOf$int_A$int(array, valueToFind);
            } else if (((array != null && array instanceof <any>Array && (array.length == 0 || array[0] == null ||(typeof array[0] === 'number'))) || array === null) && ((typeof valueToFind === 'number') || valueToFind === null) && startIndex === undefined && tolerance === undefined) {
                return <any>org.openprovenance.apache.commons.lang.ArrayUtils.lastIndexOf$long_A$long(array, valueToFind);
            } else if (((array != null && array instanceof <any>Array && (array.length == 0 || array[0] == null ||(typeof array[0] === 'number'))) || array === null) && ((typeof valueToFind === 'number') || valueToFind === null) && startIndex === undefined && tolerance === undefined) {
                return <any>org.openprovenance.apache.commons.lang.ArrayUtils.lastIndexOf$float_A$float(array, valueToFind);
            } else if (((array != null && array instanceof <any>Array && (array.length == 0 || array[0] == null ||(typeof array[0] === 'number'))) || array === null) && ((typeof valueToFind === 'number') || valueToFind === null) && startIndex === undefined && tolerance === undefined) {
                return <any>org.openprovenance.apache.commons.lang.ArrayUtils.lastIndexOf$double_A$double(array, valueToFind);
            } else if (((array != null && array instanceof <any>Array && (array.length == 0 || array[0] == null ||(typeof array[0] === 'boolean'))) || array === null) && ((typeof valueToFind === 'boolean') || valueToFind === null) && startIndex === undefined && tolerance === undefined) {
                return <any>org.openprovenance.apache.commons.lang.ArrayUtils.lastIndexOf$boolean_A$boolean(array, valueToFind);
            } else if (((array != null && array instanceof <any>Array && (array.length == 0 || array[0] == null ||(array[0] != null))) || array === null) && ((valueToFind != null) || valueToFind === null) && startIndex === undefined && tolerance === undefined) {
                return <any>org.openprovenance.apache.commons.lang.ArrayUtils.lastIndexOf$java_lang_Object_A$java_lang_Object(array, valueToFind);
            } else throw new Error('invalid overload');
        }

        public static contains$double_A$double(array: number[], valueToFind: number): boolean {
            return ArrayUtils.indexOf$double_A$double(array, valueToFind) !== ArrayUtils.INDEX_NOT_FOUND;
        }

        public static contains$double_A$double$double(array: number[], valueToFind: number, tolerance: number): boolean {
            return ArrayUtils.indexOf$double_A$double$int$double(array, valueToFind, 0, tolerance) !== ArrayUtils.INDEX_NOT_FOUND;
        }

        /**
         * <p>Checks if a value falling within the given tolerance is in the
         * given array.  If the array contains a value within the inclusive range
         * defined by (value - tolerance) to (value + tolerance).</p>
         * 
         * <p>The method returns <code>false</code> if a <code>null</code> array
         * is passed in.</p>
         * 
         * @param {double[]} array  the array to search
         * @param {number} valueToFind  the value to find
         * @param {number} tolerance  the array contains the tolerance of the search
         * @return {boolean} true if value falling within tolerance is in array
         */
        public static contains(array?: any, valueToFind?: any, tolerance?: any): any {
            if (((array != null && array instanceof <any>Array && (array.length == 0 || array[0] == null ||(typeof array[0] === 'number'))) || array === null) && ((typeof valueToFind === 'number') || valueToFind === null) && ((typeof tolerance === 'number') || tolerance === null)) {
                return <any>org.openprovenance.apache.commons.lang.ArrayUtils.contains$double_A$double$double(array, valueToFind, tolerance);
            } else if (((array != null && array instanceof <any>Array && (array.length == 0 || array[0] == null ||(typeof array[0] === 'number'))) || array === null) && ((typeof valueToFind === 'number') || valueToFind === null) && tolerance === undefined) {
                return <any>org.openprovenance.apache.commons.lang.ArrayUtils.contains$short_A$short(array, valueToFind);
            } else if (((array != null && array instanceof <any>Array && (array.length == 0 || array[0] == null ||(typeof array[0] === 'string'))) || array === null) && ((typeof valueToFind === 'string') || valueToFind === null) && tolerance === undefined) {
                return <any>org.openprovenance.apache.commons.lang.ArrayUtils.contains$char_A$char(array, valueToFind);
            } else if (((array != null && array instanceof <any>Array && (array.length == 0 || array[0] == null ||(typeof array[0] === 'number'))) || array === null) && ((typeof valueToFind === 'number') || valueToFind === null) && tolerance === undefined) {
                return <any>org.openprovenance.apache.commons.lang.ArrayUtils.contains$byte_A$byte(array, valueToFind);
            } else if (((array != null && array instanceof <any>Array && (array.length == 0 || array[0] == null ||(typeof array[0] === 'number'))) || array === null) && ((typeof valueToFind === 'number') || valueToFind === null) && tolerance === undefined) {
                return <any>org.openprovenance.apache.commons.lang.ArrayUtils.contains$int_A$int(array, valueToFind);
            } else if (((array != null && array instanceof <any>Array && (array.length == 0 || array[0] == null ||(typeof array[0] === 'number'))) || array === null) && ((typeof valueToFind === 'number') || valueToFind === null) && tolerance === undefined) {
                return <any>org.openprovenance.apache.commons.lang.ArrayUtils.contains$long_A$long(array, valueToFind);
            } else if (((array != null && array instanceof <any>Array && (array.length == 0 || array[0] == null ||(typeof array[0] === 'number'))) || array === null) && ((typeof valueToFind === 'number') || valueToFind === null) && tolerance === undefined) {
                return <any>org.openprovenance.apache.commons.lang.ArrayUtils.contains$float_A$float(array, valueToFind);
            } else if (((array != null && array instanceof <any>Array && (array.length == 0 || array[0] == null ||(typeof array[0] === 'number'))) || array === null) && ((typeof valueToFind === 'number') || valueToFind === null) && tolerance === undefined) {
                return <any>org.openprovenance.apache.commons.lang.ArrayUtils.contains$double_A$double(array, valueToFind);
            } else if (((array != null && array instanceof <any>Array && (array.length == 0 || array[0] == null ||(typeof array[0] === 'boolean'))) || array === null) && ((typeof valueToFind === 'boolean') || valueToFind === null) && tolerance === undefined) {
                return <any>org.openprovenance.apache.commons.lang.ArrayUtils.contains$boolean_A$boolean(array, valueToFind);
            } else if (((array != null && array instanceof <any>Array && (array.length == 0 || array[0] == null ||(array[0] != null))) || array === null) && ((valueToFind != null) || valueToFind === null) && tolerance === undefined) {
                return <any>org.openprovenance.apache.commons.lang.ArrayUtils.contains$java_lang_Object_A$java_lang_Object(array, valueToFind);
            } else throw new Error('invalid overload');
        }

        public static indexOf$float_A$float(array: number[], valueToFind: number): number {
            return ArrayUtils.indexOf$float_A$float$int(array, valueToFind, 0);
        }

        public static indexOf$float_A$float$int(array: number[], valueToFind: number, startIndex: number): number {
            if (ArrayUtils.isEmpty$float_A(array)){
                return ArrayUtils.INDEX_NOT_FOUND;
            }
            if (startIndex < 0){
                startIndex = 0;
            }
            for(let i: number = startIndex; i < array.length; i++) {{
                if (valueToFind === array[i]){
                    return i;
                }
            };}
            return ArrayUtils.INDEX_NOT_FOUND;
        }

        public static lastIndexOf$float_A$float(array: number[], valueToFind: number): number {
            return ArrayUtils.lastIndexOf$float_A$float$int(array, valueToFind, 2147483647);
        }

        public static lastIndexOf$float_A$float$int(array: number[], valueToFind: number, startIndex: number): number {
            if (ArrayUtils.isEmpty$float_A(array)){
                return ArrayUtils.INDEX_NOT_FOUND;
            }
            if (startIndex < 0){
                return ArrayUtils.INDEX_NOT_FOUND;
            } else if (startIndex >= array.length){
                startIndex = array.length - 1;
            }
            for(let i: number = startIndex; i >= 0; i--) {{
                if (valueToFind === array[i]){
                    return i;
                }
            };}
            return ArrayUtils.INDEX_NOT_FOUND;
        }

        public static contains$float_A$float(array: number[], valueToFind: number): boolean {
            return ArrayUtils.indexOf$float_A$float(array, valueToFind) !== ArrayUtils.INDEX_NOT_FOUND;
        }

        public static indexOf$boolean_A$boolean(array: boolean[], valueToFind: boolean): number {
            return ArrayUtils.indexOf$boolean_A$boolean$int(array, valueToFind, 0);
        }

        public static indexOf$boolean_A$boolean$int(array: boolean[], valueToFind: boolean, startIndex: number): number {
            if (ArrayUtils.isEmpty$boolean_A(array)){
                return ArrayUtils.INDEX_NOT_FOUND;
            }
            if (startIndex < 0){
                startIndex = 0;
            }
            for(let i: number = startIndex; i < array.length; i++) {{
                if (valueToFind === array[i]){
                    return i;
                }
            };}
            return ArrayUtils.INDEX_NOT_FOUND;
        }

        public static lastIndexOf$boolean_A$boolean(array: boolean[], valueToFind: boolean): number {
            return ArrayUtils.lastIndexOf$boolean_A$boolean$int(array, valueToFind, 2147483647);
        }

        public static lastIndexOf$boolean_A$boolean$int(array: boolean[], valueToFind: boolean, startIndex: number): number {
            if (ArrayUtils.isEmpty$boolean_A(array)){
                return ArrayUtils.INDEX_NOT_FOUND;
            }
            if (startIndex < 0){
                return ArrayUtils.INDEX_NOT_FOUND;
            } else if (startIndex >= array.length){
                startIndex = array.length - 1;
            }
            for(let i: number = startIndex; i >= 0; i--) {{
                if (valueToFind === array[i]){
                    return i;
                }
            };}
            return ArrayUtils.INDEX_NOT_FOUND;
        }

        public static contains$boolean_A$boolean(array: boolean[], valueToFind: boolean): boolean {
            return ArrayUtils.indexOf$boolean_A$boolean(array, valueToFind) !== ArrayUtils.INDEX_NOT_FOUND;
        }

        public static toPrimitive$java_lang_Character_A(array: string[]): string[] {
            if (array == null){
                return null;
            } else if (array.length === 0){
                return ArrayUtils.EMPTY_CHAR_ARRAY_$LI$();
            }
            const result: string[] = (s => { let a=[]; while(s-->0) a.push(null); return a; })(array.length);
            for(let i: number = 0; i < array.length; i++) {{
                result[i] = /* charValue */array[i];
            };}
            return result;
        }

        public static toPrimitive$java_lang_Character_A$char(array: string[], valueForNull: string): string[] {
            if (array == null){
                return null;
            } else if (array.length === 0){
                return ArrayUtils.EMPTY_CHAR_ARRAY_$LI$();
            }
            const result: string[] = (s => { let a=[]; while(s-->0) a.push(null); return a; })(array.length);
            for(let i: number = 0; i < array.length; i++) {{
                const b: string = array[i];
                result[i] = ((c => c.charCodeAt==null?<any>c:c.charCodeAt(0))(b) == null ? valueForNull : /* charValue */b);
            };}
            return result;
        }

        /**
         * <p>Converts an array of object Character to primitives handling <code>null</code>.</p>
         * 
         * <p>This method returns <code>null</code> for a <code>null</code> input array.</p>
         * 
         * @param {java.lang.Character[]} array  a <code>Character</code> array, may be <code>null</code>
         * @param {string} valueForNull  the value to insert if <code>null</code> found
         * @return {char[]} a <code>char</code> array, <code>null</code> if null array input
         */
        public static toPrimitive(array?: any, valueForNull?: any): any {
            if (((array != null && array instanceof <any>Array && (array.length == 0 || array[0] == null ||(typeof array[0] === 'string'))) || array === null) && ((typeof valueForNull === 'string') || valueForNull === null)) {
                return <any>org.openprovenance.apache.commons.lang.ArrayUtils.toPrimitive$java_lang_Character_A$char(array, valueForNull);
            } else if (((array != null && array instanceof <any>Array && (array.length == 0 || array[0] == null ||(typeof array[0] === 'number'))) || array === null) && ((typeof valueForNull === 'number') || valueForNull === null)) {
                return <any>org.openprovenance.apache.commons.lang.ArrayUtils.toPrimitive$java_lang_Byte_A$byte(array, valueForNull);
            } else if (((array != null && array instanceof <any>Array && (array.length == 0 || array[0] == null ||(typeof array[0] === 'number'))) || array === null) && ((typeof valueForNull === 'number') || valueForNull === null)) {
                return <any>org.openprovenance.apache.commons.lang.ArrayUtils.toPrimitive$java_lang_Short_A$short(array, valueForNull);
            } else if (((array != null && array instanceof <any>Array && (array.length == 0 || array[0] == null ||(typeof array[0] === 'number'))) || array === null) && ((typeof valueForNull === 'number') || valueForNull === null)) {
                return <any>org.openprovenance.apache.commons.lang.ArrayUtils.toPrimitive$java_lang_Integer_A$int(array, valueForNull);
            } else if (((array != null && array instanceof <any>Array && (array.length == 0 || array[0] == null ||(typeof array[0] === 'number'))) || array === null) && ((typeof valueForNull === 'number') || valueForNull === null)) {
                return <any>org.openprovenance.apache.commons.lang.ArrayUtils.toPrimitive$java_lang_Long_A$long(array, valueForNull);
            } else if (((array != null && array instanceof <any>Array && (array.length == 0 || array[0] == null ||(typeof array[0] === 'number'))) || array === null) && ((typeof valueForNull === 'number') || valueForNull === null)) {
                return <any>org.openprovenance.apache.commons.lang.ArrayUtils.toPrimitive$java_lang_Float_A$float(array, valueForNull);
            } else if (((array != null && array instanceof <any>Array && (array.length == 0 || array[0] == null ||(typeof array[0] === 'number'))) || array === null) && ((typeof valueForNull === 'number') || valueForNull === null)) {
                return <any>org.openprovenance.apache.commons.lang.ArrayUtils.toPrimitive$java_lang_Double_A$double(array, valueForNull);
            } else if (((array != null && array instanceof <any>Array && (array.length == 0 || array[0] == null ||(typeof array[0] === 'boolean'))) || array === null) && ((typeof valueForNull === 'boolean') || valueForNull === null)) {
                return <any>org.openprovenance.apache.commons.lang.ArrayUtils.toPrimitive$java_lang_Boolean_A$boolean(array, valueForNull);
            } else if (((array != null && array instanceof <any>Array && (array.length == 0 || array[0] == null ||(typeof array[0] === 'string'))) || array === null) && valueForNull === undefined) {
                return <any>org.openprovenance.apache.commons.lang.ArrayUtils.toPrimitive$java_lang_Character_A(array);
            } else if (((array != null && array instanceof <any>Array && (array.length == 0 || array[0] == null ||(typeof array[0] === 'number'))) || array === null) && valueForNull === undefined) {
                return <any>org.openprovenance.apache.commons.lang.ArrayUtils.toPrimitive$java_lang_Long_A(array);
            } else if (((array != null && array instanceof <any>Array && (array.length == 0 || array[0] == null ||(typeof array[0] === 'number'))) || array === null) && valueForNull === undefined) {
                return <any>org.openprovenance.apache.commons.lang.ArrayUtils.toPrimitive$java_lang_Integer_A(array);
            } else if (((array != null && array instanceof <any>Array && (array.length == 0 || array[0] == null ||(typeof array[0] === 'number'))) || array === null) && valueForNull === undefined) {
                return <any>org.openprovenance.apache.commons.lang.ArrayUtils.toPrimitive$java_lang_Short_A(array);
            } else if (((array != null && array instanceof <any>Array && (array.length == 0 || array[0] == null ||(typeof array[0] === 'number'))) || array === null) && valueForNull === undefined) {
                return <any>org.openprovenance.apache.commons.lang.ArrayUtils.toPrimitive$java_lang_Byte_A(array);
            } else if (((array != null && array instanceof <any>Array && (array.length == 0 || array[0] == null ||(typeof array[0] === 'number'))) || array === null) && valueForNull === undefined) {
                return <any>org.openprovenance.apache.commons.lang.ArrayUtils.toPrimitive$java_lang_Double_A(array);
            } else if (((array != null && array instanceof <any>Array && (array.length == 0 || array[0] == null ||(typeof array[0] === 'number'))) || array === null) && valueForNull === undefined) {
                return <any>org.openprovenance.apache.commons.lang.ArrayUtils.toPrimitive$java_lang_Float_A(array);
            } else if (((array != null && array instanceof <any>Array && (array.length == 0 || array[0] == null ||(typeof array[0] === 'boolean'))) || array === null) && valueForNull === undefined) {
                return <any>org.openprovenance.apache.commons.lang.ArrayUtils.toPrimitive$java_lang_Boolean_A(array);
            } else throw new Error('invalid overload');
        }

        public static toObject$char_A(array: string[]): string[] {
            if (array == null){
                return null;
            } else if (array.length === 0){
                return ArrayUtils.EMPTY_CHARACTER_OBJECT_ARRAY_$LI$();
            }
            const result: string[] = (s => { let a=[]; while(s-->0) a.push(null); return a; })(array.length);
            for(let i: number = 0; i < array.length; i++) {{
                result[i] = <string>new String(array[i]);
            };}
            return result;
        }

        /**
         * <p>Converts an array of primitive chars to objects.</p>
         * 
         * <p>This method returns <code>null</code> for a <code>null</code> input array.</p>
         * 
         * @param {char[]} array a <code>char</code> array
         * @return {java.lang.Character[]} a <code>Character</code> array, <code>null</code> if null array input
         */
        public static toObject(array?: any): any {
            if (((array != null && array instanceof <any>Array && (array.length == 0 || array[0] == null ||(typeof array[0] === 'string'))) || array === null)) {
                return <any>org.openprovenance.apache.commons.lang.ArrayUtils.toObject$char_A(array);
            } else if (((array != null && array instanceof <any>Array && (array.length == 0 || array[0] == null ||(typeof array[0] === 'number'))) || array === null)) {
                return <any>org.openprovenance.apache.commons.lang.ArrayUtils.toObject$long_A(array);
            } else if (((array != null && array instanceof <any>Array && (array.length == 0 || array[0] == null ||(typeof array[0] === 'number'))) || array === null)) {
                return <any>org.openprovenance.apache.commons.lang.ArrayUtils.toObject$int_A(array);
            } else if (((array != null && array instanceof <any>Array && (array.length == 0 || array[0] == null ||(typeof array[0] === 'number'))) || array === null)) {
                return <any>org.openprovenance.apache.commons.lang.ArrayUtils.toObject$short_A(array);
            } else if (((array != null && array instanceof <any>Array && (array.length == 0 || array[0] == null ||(typeof array[0] === 'number'))) || array === null)) {
                return <any>org.openprovenance.apache.commons.lang.ArrayUtils.toObject$byte_A(array);
            } else if (((array != null && array instanceof <any>Array && (array.length == 0 || array[0] == null ||(typeof array[0] === 'number'))) || array === null)) {
                return <any>org.openprovenance.apache.commons.lang.ArrayUtils.toObject$double_A(array);
            } else if (((array != null && array instanceof <any>Array && (array.length == 0 || array[0] == null ||(typeof array[0] === 'number'))) || array === null)) {
                return <any>org.openprovenance.apache.commons.lang.ArrayUtils.toObject$float_A(array);
            } else if (((array != null && array instanceof <any>Array && (array.length == 0 || array[0] == null ||(typeof array[0] === 'boolean'))) || array === null)) {
                return <any>org.openprovenance.apache.commons.lang.ArrayUtils.toObject$boolean_A(array);
            } else throw new Error('invalid overload');
        }

        public static toPrimitive$java_lang_Long_A(array: number[]): number[] {
            if (array == null){
                return null;
            } else if (array.length === 0){
                return ArrayUtils.EMPTY_LONG_ARRAY_$LI$();
            }
            const result: number[] = (s => { let a=[]; while(s-->0) a.push(0); return a; })(array.length);
            for(let i: number = 0; i < array.length; i++) {{
                result[i] = /* longValue */array[i];
            };}
            return result;
        }

        public static toPrimitive$java_lang_Long_A$long(array: number[], valueForNull: number): number[] {
            if (array == null){
                return null;
            } else if (array.length === 0){
                return ArrayUtils.EMPTY_LONG_ARRAY_$LI$();
            }
            const result: number[] = (s => { let a=[]; while(s-->0) a.push(0); return a; })(array.length);
            for(let i: number = 0; i < array.length; i++) {{
                const b: number = array[i];
                result[i] = (b == null ? valueForNull : /* longValue */b);
            };}
            return result;
        }

        public static toObject$long_A(array: number[]): number[] {
            if (array == null){
                return null;
            } else if (array.length === 0){
                return ArrayUtils.EMPTY_LONG_OBJECT_ARRAY_$LI$();
            }
            const result: number[] = (s => { let a=[]; while(s-->0) a.push(null); return a; })(array.length);
            for(let i: number = 0; i < array.length; i++) {{
                result[i] = new Number(array[i]).valueOf();
            };}
            return result;
        }

        public static toPrimitive$java_lang_Integer_A(array: number[]): number[] {
            if (array == null){
                return null;
            } else if (array.length === 0){
                return ArrayUtils.EMPTY_INT_ARRAY_$LI$();
            }
            const result: number[] = (s => { let a=[]; while(s-->0) a.push(0); return a; })(array.length);
            for(let i: number = 0; i < array.length; i++) {{
                result[i] = /* intValue */(array[i]|0);
            };}
            return result;
        }

        public static toPrimitive$java_lang_Integer_A$int(array: number[], valueForNull: number): number[] {
            if (array == null){
                return null;
            } else if (array.length === 0){
                return ArrayUtils.EMPTY_INT_ARRAY_$LI$();
            }
            const result: number[] = (s => { let a=[]; while(s-->0) a.push(0); return a; })(array.length);
            for(let i: number = 0; i < array.length; i++) {{
                const b: number = array[i];
                result[i] = (b == null ? valueForNull : /* intValue */(b|0));
            };}
            return result;
        }

        public static toObject$int_A(array: number[]): number[] {
            if (array == null){
                return null;
            } else if (array.length === 0){
                return ArrayUtils.EMPTY_INTEGER_OBJECT_ARRAY_$LI$();
            }
            const result: number[] = (s => { let a=[]; while(s-->0) a.push(null); return a; })(array.length);
            for(let i: number = 0; i < array.length; i++) {{
                result[i] = new Number(array[i]).valueOf();
            };}
            return result;
        }

        public static toPrimitive$java_lang_Short_A(array: number[]): number[] {
            if (array == null){
                return null;
            } else if (array.length === 0){
                return ArrayUtils.EMPTY_SHORT_ARRAY_$LI$();
            }
            const result: number[] = (s => { let a=[]; while(s-->0) a.push(0); return a; })(array.length);
            for(let i: number = 0; i < array.length; i++) {{
                result[i] = /* shortValue */(array[i]|0);
            };}
            return result;
        }

        public static toPrimitive$java_lang_Short_A$short(array: number[], valueForNull: number): number[] {
            if (array == null){
                return null;
            } else if (array.length === 0){
                return ArrayUtils.EMPTY_SHORT_ARRAY_$LI$();
            }
            const result: number[] = (s => { let a=[]; while(s-->0) a.push(0); return a; })(array.length);
            for(let i: number = 0; i < array.length; i++) {{
                const b: number = array[i];
                result[i] = (b == null ? valueForNull : /* shortValue */(b|0));
            };}
            return result;
        }

        public static toObject$short_A(array: number[]): number[] {
            if (array == null){
                return null;
            } else if (array.length === 0){
                return ArrayUtils.EMPTY_SHORT_OBJECT_ARRAY_$LI$();
            }
            const result: number[] = (s => { let a=[]; while(s-->0) a.push(null); return a; })(array.length);
            for(let i: number = 0; i < array.length; i++) {{
                result[i] = <number>new Number(array[i]);
            };}
            return result;
        }

        public static toPrimitive$java_lang_Byte_A(array: number[]): number[] {
            if (array == null){
                return null;
            } else if (array.length === 0){
                return ArrayUtils.EMPTY_BYTE_ARRAY_$LI$();
            }
            const result: number[] = (s => { let a=[]; while(s-->0) a.push(0); return a; })(array.length);
            for(let i: number = 0; i < array.length; i++) {{
                result[i] = /* byteValue */(array[i]|0);
            };}
            return result;
        }

        public static toPrimitive$java_lang_Byte_A$byte(array: number[], valueForNull: number): number[] {
            if (array == null){
                return null;
            } else if (array.length === 0){
                return ArrayUtils.EMPTY_BYTE_ARRAY_$LI$();
            }
            const result: number[] = (s => { let a=[]; while(s-->0) a.push(0); return a; })(array.length);
            for(let i: number = 0; i < array.length; i++) {{
                const b: number = array[i];
                result[i] = (b == null ? valueForNull : /* byteValue */(b|0));
            };}
            return result;
        }

        public static toObject$byte_A(array: number[]): number[] {
            if (array == null){
                return null;
            } else if (array.length === 0){
                return ArrayUtils.EMPTY_BYTE_OBJECT_ARRAY_$LI$();
            }
            const result: number[] = (s => { let a=[]; while(s-->0) a.push(null); return a; })(array.length);
            for(let i: number = 0; i < array.length; i++) {{
                result[i] = <number>new Number(array[i]);
            };}
            return result;
        }

        public static toPrimitive$java_lang_Double_A(array: number[]): number[] {
            if (array == null){
                return null;
            } else if (array.length === 0){
                return ArrayUtils.EMPTY_DOUBLE_ARRAY_$LI$();
            }
            const result: number[] = (s => { let a=[]; while(s-->0) a.push(0); return a; })(array.length);
            for(let i: number = 0; i < array.length; i++) {{
                result[i] = /* doubleValue */array[i];
            };}
            return result;
        }

        public static toPrimitive$java_lang_Double_A$double(array: number[], valueForNull: number): number[] {
            if (array == null){
                return null;
            } else if (array.length === 0){
                return ArrayUtils.EMPTY_DOUBLE_ARRAY_$LI$();
            }
            const result: number[] = (s => { let a=[]; while(s-->0) a.push(0); return a; })(array.length);
            for(let i: number = 0; i < array.length; i++) {{
                const b: number = array[i];
                result[i] = (b == null ? valueForNull : /* doubleValue */b);
            };}
            return result;
        }

        public static toObject$double_A(array: number[]): number[] {
            if (array == null){
                return null;
            } else if (array.length === 0){
                return ArrayUtils.EMPTY_DOUBLE_OBJECT_ARRAY_$LI$();
            }
            const result: number[] = (s => { let a=[]; while(s-->0) a.push(null); return a; })(array.length);
            for(let i: number = 0; i < array.length; i++) {{
                result[i] = new Number(array[i]).valueOf();
            };}
            return result;
        }

        public static toPrimitive$java_lang_Float_A(array: number[]): number[] {
            if (array == null){
                return null;
            } else if (array.length === 0){
                return ArrayUtils.EMPTY_FLOAT_ARRAY_$LI$();
            }
            const result: number[] = (s => { let a=[]; while(s-->0) a.push(0); return a; })(array.length);
            for(let i: number = 0; i < array.length; i++) {{
                result[i] = /* floatValue */array[i];
            };}
            return result;
        }

        public static toPrimitive$java_lang_Float_A$float(array: number[], valueForNull: number): number[] {
            if (array == null){
                return null;
            } else if (array.length === 0){
                return ArrayUtils.EMPTY_FLOAT_ARRAY_$LI$();
            }
            const result: number[] = (s => { let a=[]; while(s-->0) a.push(0); return a; })(array.length);
            for(let i: number = 0; i < array.length; i++) {{
                const b: number = array[i];
                result[i] = (b == null ? valueForNull : /* floatValue */b);
            };}
            return result;
        }

        public static toObject$float_A(array: number[]): number[] {
            if (array == null){
                return null;
            } else if (array.length === 0){
                return ArrayUtils.EMPTY_FLOAT_OBJECT_ARRAY_$LI$();
            }
            const result: number[] = (s => { let a=[]; while(s-->0) a.push(null); return a; })(array.length);
            for(let i: number = 0; i < array.length; i++) {{
                result[i] = new Number(array[i]).valueOf();
            };}
            return result;
        }

        public static toPrimitive$java_lang_Boolean_A(array: boolean[]): boolean[] {
            if (array == null){
                return null;
            } else if (array.length === 0){
                return ArrayUtils.EMPTY_BOOLEAN_ARRAY_$LI$();
            }
            const result: boolean[] = (s => { let a=[]; while(s-->0) a.push(false); return a; })(array.length);
            for(let i: number = 0; i < array.length; i++) {{
                result[i] = /* booleanValue */array[i];
            };}
            return result;
        }

        public static toPrimitive$java_lang_Boolean_A$boolean(array: boolean[], valueForNull: boolean): boolean[] {
            if (array == null){
                return null;
            } else if (array.length === 0){
                return ArrayUtils.EMPTY_BOOLEAN_ARRAY_$LI$();
            }
            const result: boolean[] = (s => { let a=[]; while(s-->0) a.push(false); return a; })(array.length);
            for(let i: number = 0; i < array.length; i++) {{
                const b: boolean = array[i];
                result[i] = (b == null ? valueForNull : /* booleanValue */b);
            };}
            return result;
        }

        public static toObject$boolean_A(array: boolean[]): boolean[] {
            if (array == null){
                return null;
            } else if (array.length === 0){
                return ArrayUtils.EMPTY_BOOLEAN_OBJECT_ARRAY_$LI$();
            }
            const result: boolean[] = (s => { let a=[]; while(s-->0) a.push(null); return a; })(array.length);
            for(let i: number = 0; i < array.length; i++) {{
                result[i] = (array[i] ? true : false);
            };}
            return result;
        }

        public static isEmpty$java_lang_Object_A(array: any[]): boolean {
            return array == null || array.length === 0;
        }

        /**
         * <p>Checks if an array of Objects is empty or <code>null</code>.</p>
         * 
         * @param {java.lang.Object[]} array  the array to test
         * @return {boolean} <code>true</code> if the array is empty or <code>null</code>
         * @since 2.1
         */
        public static isEmpty(array?: any): any {
            if (((array != null && array instanceof <any>Array && (array.length == 0 || array[0] == null ||(array[0] != null))) || array === null)) {
                return <any>org.openprovenance.apache.commons.lang.ArrayUtils.isEmpty$java_lang_Object_A(array);
            } else if (((array != null && array instanceof <any>Array && (array.length == 0 || array[0] == null ||(typeof array[0] === 'number'))) || array === null)) {
                return <any>org.openprovenance.apache.commons.lang.ArrayUtils.isEmpty$long_A(array);
            } else if (((array != null && array instanceof <any>Array && (array.length == 0 || array[0] == null ||(typeof array[0] === 'number'))) || array === null)) {
                return <any>org.openprovenance.apache.commons.lang.ArrayUtils.isEmpty$int_A(array);
            } else if (((array != null && array instanceof <any>Array && (array.length == 0 || array[0] == null ||(typeof array[0] === 'number'))) || array === null)) {
                return <any>org.openprovenance.apache.commons.lang.ArrayUtils.isEmpty$short_A(array);
            } else if (((array != null && array instanceof <any>Array && (array.length == 0 || array[0] == null ||(typeof array[0] === 'string'))) || array === null)) {
                return <any>org.openprovenance.apache.commons.lang.ArrayUtils.isEmpty$char_A(array);
            } else if (((array != null && array instanceof <any>Array && (array.length == 0 || array[0] == null ||(typeof array[0] === 'number'))) || array === null)) {
                return <any>org.openprovenance.apache.commons.lang.ArrayUtils.isEmpty$byte_A(array);
            } else if (((array != null && array instanceof <any>Array && (array.length == 0 || array[0] == null ||(typeof array[0] === 'number'))) || array === null)) {
                return <any>org.openprovenance.apache.commons.lang.ArrayUtils.isEmpty$double_A(array);
            } else if (((array != null && array instanceof <any>Array && (array.length == 0 || array[0] == null ||(typeof array[0] === 'number'))) || array === null)) {
                return <any>org.openprovenance.apache.commons.lang.ArrayUtils.isEmpty$float_A(array);
            } else if (((array != null && array instanceof <any>Array && (array.length == 0 || array[0] == null ||(typeof array[0] === 'boolean'))) || array === null)) {
                return <any>org.openprovenance.apache.commons.lang.ArrayUtils.isEmpty$boolean_A(array);
            } else throw new Error('invalid overload');
        }

        public static isEmpty$long_A(array: number[]): boolean {
            return array == null || array.length === 0;
        }

        public static isEmpty$int_A(array: number[]): boolean {
            return array == null || array.length === 0;
        }

        public static isEmpty$short_A(array: number[]): boolean {
            return array == null || array.length === 0;
        }

        public static isEmpty$char_A(array: string[]): boolean {
            return array == null || array.length === 0;
        }

        public static isEmpty$byte_A(array: number[]): boolean {
            return array == null || array.length === 0;
        }

        public static isEmpty$double_A(array: number[]): boolean {
            return array == null || array.length === 0;
        }

        public static isEmpty$float_A(array: number[]): boolean {
            return array == null || array.length === 0;
        }

        public static isEmpty$boolean_A(array: boolean[]): boolean {
            return array == null || array.length === 0;
        }

        public static isNotEmpty$java_lang_Object_A(array: any[]): boolean {
            return (array != null && array.length !== 0);
        }

        /**
         * <p>Checks if an array of Objects is not empty or not <code>null</code>.</p>
         * 
         * @param {java.lang.Object[]} array  the array to test
         * @return {boolean} <code>true</code> if the array is not empty or not <code>null</code>
         * @since 2.5
         */
        public static isNotEmpty(array?: any): any {
            if (((array != null && array instanceof <any>Array && (array.length == 0 || array[0] == null ||(array[0] != null))) || array === null)) {
                return <any>org.openprovenance.apache.commons.lang.ArrayUtils.isNotEmpty$java_lang_Object_A(array);
            } else if (((array != null && array instanceof <any>Array && (array.length == 0 || array[0] == null ||(typeof array[0] === 'number'))) || array === null)) {
                return <any>org.openprovenance.apache.commons.lang.ArrayUtils.isNotEmpty$long_A(array);
            } else if (((array != null && array instanceof <any>Array && (array.length == 0 || array[0] == null ||(typeof array[0] === 'number'))) || array === null)) {
                return <any>org.openprovenance.apache.commons.lang.ArrayUtils.isNotEmpty$int_A(array);
            } else if (((array != null && array instanceof <any>Array && (array.length == 0 || array[0] == null ||(typeof array[0] === 'number'))) || array === null)) {
                return <any>org.openprovenance.apache.commons.lang.ArrayUtils.isNotEmpty$short_A(array);
            } else if (((array != null && array instanceof <any>Array && (array.length == 0 || array[0] == null ||(typeof array[0] === 'string'))) || array === null)) {
                return <any>org.openprovenance.apache.commons.lang.ArrayUtils.isNotEmpty$char_A(array);
            } else if (((array != null && array instanceof <any>Array && (array.length == 0 || array[0] == null ||(typeof array[0] === 'number'))) || array === null)) {
                return <any>org.openprovenance.apache.commons.lang.ArrayUtils.isNotEmpty$byte_A(array);
            } else if (((array != null && array instanceof <any>Array && (array.length == 0 || array[0] == null ||(typeof array[0] === 'number'))) || array === null)) {
                return <any>org.openprovenance.apache.commons.lang.ArrayUtils.isNotEmpty$double_A(array);
            } else if (((array != null && array instanceof <any>Array && (array.length == 0 || array[0] == null ||(typeof array[0] === 'number'))) || array === null)) {
                return <any>org.openprovenance.apache.commons.lang.ArrayUtils.isNotEmpty$float_A(array);
            } else if (((array != null && array instanceof <any>Array && (array.length == 0 || array[0] == null ||(typeof array[0] === 'boolean'))) || array === null)) {
                return <any>org.openprovenance.apache.commons.lang.ArrayUtils.isNotEmpty$boolean_A(array);
            } else throw new Error('invalid overload');
        }

        public static isNotEmpty$long_A(array: number[]): boolean {
            return (array != null && array.length !== 0);
        }

        public static isNotEmpty$int_A(array: number[]): boolean {
            return (array != null && array.length !== 0);
        }

        public static isNotEmpty$short_A(array: number[]): boolean {
            return (array != null && array.length !== 0);
        }

        public static isNotEmpty$char_A(array: string[]): boolean {
            return (array != null && array.length !== 0);
        }

        public static isNotEmpty$byte_A(array: number[]): boolean {
            return (array != null && array.length !== 0);
        }

        public static isNotEmpty$double_A(array: number[]): boolean {
            return (array != null && array.length !== 0);
        }

        public static isNotEmpty$float_A(array: number[]): boolean {
            return (array != null && array.length !== 0);
        }

        public static isNotEmpty$boolean_A(array: boolean[]): boolean {
            return (array != null && array.length !== 0);
        }

        public static addAll$java_lang_Object_A$java_lang_Object_A(array1: any[], array2: any[]): any[] {
            if (array1 == null){
                return /* clone */ArrayUtils.clone$java_lang_Object_A(array2);
            } else if (array2 == null){
                return /* clone */ArrayUtils.clone$java_lang_Object_A(array1);
            }
            const joinedArray: any[] = <any[]>/* newInstance */new Array<any>(array1.length + array2.length);
            /* arraycopy */((srcPts, srcOff, dstPts, dstOff, size) => { if(srcPts !== dstPts || dstOff >= srcOff + size) { while (--size >= 0) dstPts[dstOff++] = srcPts[srcOff++];} else { let tmp = srcPts.slice(srcOff, srcOff + size); for (let i = 0; i < size; i++) dstPts[dstOff++] = tmp[i]; }})(array1, 0, joinedArray, 0, array1.length);
            try {
                /* arraycopy */((srcPts, srcOff, dstPts, dstOff, size) => { if(srcPts !== dstPts || dstOff >= srcOff + size) { while (--size >= 0) dstPts[dstOff++] = srcPts[srcOff++];} else { let tmp = srcPts.slice(srcOff, srcOff + size); for (let i = 0; i < size; i++) dstPts[dstOff++] = tmp[i]; }})(array2, 0, joinedArray, array1.length, array2.length);
            } catch(ase) {
                const type1: any = (<any>array1.constructor).getComponentType();
                const type2: any = (<any>array2.constructor).getComponentType();
                if (!type1.isAssignableFrom(type2)){
                    throw Object.defineProperty(new Error("Cannot store " + /* getName */(c => typeof c === 'string' ? c : c["__class"] ? c["__class"] : c["name"])(type2) + " in an array of " + /* getName */(c => typeof c === 'string' ? c : c["__class"] ? c["__class"] : c["name"])(type1)), '__classes', { configurable: true, value: ['java.lang.Throwable','java.lang.Object','java.lang.RuntimeException','java.lang.IllegalArgumentException','java.lang.Exception'] });
                }
                throw ase;
            }
            return joinedArray;
        }

        /**
         * <p>Adds all the elements of the given arrays into a new array.</p>
         * <p>The new array contains all of the element of <code>array1</code> followed
         * by all of the elements <code>array2</code>. When an array is returned, it is always
         * a new array.</p>
         * 
         * <pre>
         * ArrayUtils.addAll(null, null)     = null
         * ArrayUtils.addAll(array1, null)   = cloned copy of array1
         * ArrayUtils.addAll(null, array2)   = cloned copy of array2
         * ArrayUtils.addAll([], [])         = []
         * ArrayUtils.addAll([null], [null]) = [null, null]
         * ArrayUtils.addAll(["a", "b", "c"], ["1", "2", "3"]) = ["a", "b", "c", "1", "2", "3"]
         * </pre>
         * 
         * @param {java.lang.Object[]} array1  the first array whose elements are added to the new array, may be <code>null</code>
         * @param {java.lang.Object[]} array2  the second array whose elements are added to the new array, may be <code>null</code>
         * @return {java.lang.Object[]} The new array, <code>null</code> if both arrays are <code>null</code>.
         * The type of the new array is the type of the first array,
         * unless the first array is null, in which case the type is the same as the second array.
         * @since 2.1
         * @throws IllegalArgumentException if the array types are incompatible
         */
        public static addAll(array1?: any, array2?: any): any {
            if (((array1 != null && array1 instanceof <any>Array && (array1.length == 0 || array1[0] == null ||(array1[0] != null))) || array1 === null) && ((array2 != null && array2 instanceof <any>Array && (array2.length == 0 || array2[0] == null ||(array2[0] != null))) || array2 === null)) {
                return <any>org.openprovenance.apache.commons.lang.ArrayUtils.addAll$java_lang_Object_A$java_lang_Object_A(array1, array2);
            } else if (((array1 != null && array1 instanceof <any>Array && (array1.length == 0 || array1[0] == null ||(typeof array1[0] === 'boolean'))) || array1 === null) && ((array2 != null && array2 instanceof <any>Array && (array2.length == 0 || array2[0] == null ||(typeof array2[0] === 'boolean'))) || array2 === null)) {
                return <any>org.openprovenance.apache.commons.lang.ArrayUtils.addAll$boolean_A$boolean_A(array1, array2);
            } else if (((array1 != null && array1 instanceof <any>Array && (array1.length == 0 || array1[0] == null ||(typeof array1[0] === 'string'))) || array1 === null) && ((array2 != null && array2 instanceof <any>Array && (array2.length == 0 || array2[0] == null ||(typeof array2[0] === 'string'))) || array2 === null)) {
                return <any>org.openprovenance.apache.commons.lang.ArrayUtils.addAll$char_A$char_A(array1, array2);
            } else if (((array1 != null && array1 instanceof <any>Array && (array1.length == 0 || array1[0] == null ||(typeof array1[0] === 'number'))) || array1 === null) && ((array2 != null && array2 instanceof <any>Array && (array2.length == 0 || array2[0] == null ||(typeof array2[0] === 'number'))) || array2 === null)) {
                return <any>org.openprovenance.apache.commons.lang.ArrayUtils.addAll$byte_A$byte_A(array1, array2);
            } else if (((array1 != null && array1 instanceof <any>Array && (array1.length == 0 || array1[0] == null ||(typeof array1[0] === 'number'))) || array1 === null) && ((array2 != null && array2 instanceof <any>Array && (array2.length == 0 || array2[0] == null ||(typeof array2[0] === 'number'))) || array2 === null)) {
                return <any>org.openprovenance.apache.commons.lang.ArrayUtils.addAll$short_A$short_A(array1, array2);
            } else if (((array1 != null && array1 instanceof <any>Array && (array1.length == 0 || array1[0] == null ||(typeof array1[0] === 'number'))) || array1 === null) && ((array2 != null && array2 instanceof <any>Array && (array2.length == 0 || array2[0] == null ||(typeof array2[0] === 'number'))) || array2 === null)) {
                return <any>org.openprovenance.apache.commons.lang.ArrayUtils.addAll$int_A$int_A(array1, array2);
            } else if (((array1 != null && array1 instanceof <any>Array && (array1.length == 0 || array1[0] == null ||(typeof array1[0] === 'number'))) || array1 === null) && ((array2 != null && array2 instanceof <any>Array && (array2.length == 0 || array2[0] == null ||(typeof array2[0] === 'number'))) || array2 === null)) {
                return <any>org.openprovenance.apache.commons.lang.ArrayUtils.addAll$long_A$long_A(array1, array2);
            } else if (((array1 != null && array1 instanceof <any>Array && (array1.length == 0 || array1[0] == null ||(typeof array1[0] === 'number'))) || array1 === null) && ((array2 != null && array2 instanceof <any>Array && (array2.length == 0 || array2[0] == null ||(typeof array2[0] === 'number'))) || array2 === null)) {
                return <any>org.openprovenance.apache.commons.lang.ArrayUtils.addAll$float_A$float_A(array1, array2);
            } else if (((array1 != null && array1 instanceof <any>Array && (array1.length == 0 || array1[0] == null ||(typeof array1[0] === 'number'))) || array1 === null) && ((array2 != null && array2 instanceof <any>Array && (array2.length == 0 || array2[0] == null ||(typeof array2[0] === 'number'))) || array2 === null)) {
                return <any>org.openprovenance.apache.commons.lang.ArrayUtils.addAll$double_A$double_A(array1, array2);
            } else throw new Error('invalid overload');
        }

        public static addAll$boolean_A$boolean_A(array1: boolean[], array2: boolean[]): boolean[] {
            if (array1 == null){
                return /* clone */ArrayUtils.clone$boolean_A(array2);
            } else if (array2 == null){
                return /* clone */ArrayUtils.clone$boolean_A(array1);
            }
            const joinedArray: boolean[] = (s => { let a=[]; while(s-->0) a.push(false); return a; })(array1.length + array2.length);
            /* arraycopy */((srcPts, srcOff, dstPts, dstOff, size) => { if(srcPts !== dstPts || dstOff >= srcOff + size) { while (--size >= 0) dstPts[dstOff++] = srcPts[srcOff++];} else { let tmp = srcPts.slice(srcOff, srcOff + size); for (let i = 0; i < size; i++) dstPts[dstOff++] = tmp[i]; }})(array1, 0, joinedArray, 0, array1.length);
            /* arraycopy */((srcPts, srcOff, dstPts, dstOff, size) => { if(srcPts !== dstPts || dstOff >= srcOff + size) { while (--size >= 0) dstPts[dstOff++] = srcPts[srcOff++];} else { let tmp = srcPts.slice(srcOff, srcOff + size); for (let i = 0; i < size; i++) dstPts[dstOff++] = tmp[i]; }})(array2, 0, joinedArray, array1.length, array2.length);
            return joinedArray;
        }

        public static addAll$char_A$char_A(array1: string[], array2: string[]): string[] {
            if (array1 == null){
                return /* clone */ArrayUtils.clone$char_A(array2);
            } else if (array2 == null){
                return /* clone */ArrayUtils.clone$char_A(array1);
            }
            const joinedArray: string[] = (s => { let a=[]; while(s-->0) a.push(null); return a; })(array1.length + array2.length);
            /* arraycopy */((srcPts, srcOff, dstPts, dstOff, size) => { if(srcPts !== dstPts || dstOff >= srcOff + size) { while (--size >= 0) dstPts[dstOff++] = srcPts[srcOff++];} else { let tmp = srcPts.slice(srcOff, srcOff + size); for (let i = 0; i < size; i++) dstPts[dstOff++] = tmp[i]; }})(array1, 0, joinedArray, 0, array1.length);
            /* arraycopy */((srcPts, srcOff, dstPts, dstOff, size) => { if(srcPts !== dstPts || dstOff >= srcOff + size) { while (--size >= 0) dstPts[dstOff++] = srcPts[srcOff++];} else { let tmp = srcPts.slice(srcOff, srcOff + size); for (let i = 0; i < size; i++) dstPts[dstOff++] = tmp[i]; }})(array2, 0, joinedArray, array1.length, array2.length);
            return joinedArray;
        }

        public static addAll$byte_A$byte_A(array1: number[], array2: number[]): number[] {
            if (array1 == null){
                return /* clone */ArrayUtils.clone$byte_A(array2);
            } else if (array2 == null){
                return /* clone */ArrayUtils.clone$byte_A(array1);
            }
            const joinedArray: number[] = (s => { let a=[]; while(s-->0) a.push(0); return a; })(array1.length + array2.length);
            /* arraycopy */((srcPts, srcOff, dstPts, dstOff, size) => { if(srcPts !== dstPts || dstOff >= srcOff + size) { while (--size >= 0) dstPts[dstOff++] = srcPts[srcOff++];} else { let tmp = srcPts.slice(srcOff, srcOff + size); for (let i = 0; i < size; i++) dstPts[dstOff++] = tmp[i]; }})(array1, 0, joinedArray, 0, array1.length);
            /* arraycopy */((srcPts, srcOff, dstPts, dstOff, size) => { if(srcPts !== dstPts || dstOff >= srcOff + size) { while (--size >= 0) dstPts[dstOff++] = srcPts[srcOff++];} else { let tmp = srcPts.slice(srcOff, srcOff + size); for (let i = 0; i < size; i++) dstPts[dstOff++] = tmp[i]; }})(array2, 0, joinedArray, array1.length, array2.length);
            return joinedArray;
        }

        public static addAll$short_A$short_A(array1: number[], array2: number[]): number[] {
            if (array1 == null){
                return /* clone */ArrayUtils.clone$short_A(array2);
            } else if (array2 == null){
                return /* clone */ArrayUtils.clone$short_A(array1);
            }
            const joinedArray: number[] = (s => { let a=[]; while(s-->0) a.push(0); return a; })(array1.length + array2.length);
            /* arraycopy */((srcPts, srcOff, dstPts, dstOff, size) => { if(srcPts !== dstPts || dstOff >= srcOff + size) { while (--size >= 0) dstPts[dstOff++] = srcPts[srcOff++];} else { let tmp = srcPts.slice(srcOff, srcOff + size); for (let i = 0; i < size; i++) dstPts[dstOff++] = tmp[i]; }})(array1, 0, joinedArray, 0, array1.length);
            /* arraycopy */((srcPts, srcOff, dstPts, dstOff, size) => { if(srcPts !== dstPts || dstOff >= srcOff + size) { while (--size >= 0) dstPts[dstOff++] = srcPts[srcOff++];} else { let tmp = srcPts.slice(srcOff, srcOff + size); for (let i = 0; i < size; i++) dstPts[dstOff++] = tmp[i]; }})(array2, 0, joinedArray, array1.length, array2.length);
            return joinedArray;
        }

        public static addAll$int_A$int_A(array1: number[], array2: number[]): number[] {
            if (array1 == null){
                return /* clone */ArrayUtils.clone$int_A(array2);
            } else if (array2 == null){
                return /* clone */ArrayUtils.clone$int_A(array1);
            }
            const joinedArray: number[] = (s => { let a=[]; while(s-->0) a.push(0); return a; })(array1.length + array2.length);
            /* arraycopy */((srcPts, srcOff, dstPts, dstOff, size) => { if(srcPts !== dstPts || dstOff >= srcOff + size) { while (--size >= 0) dstPts[dstOff++] = srcPts[srcOff++];} else { let tmp = srcPts.slice(srcOff, srcOff + size); for (let i = 0; i < size; i++) dstPts[dstOff++] = tmp[i]; }})(array1, 0, joinedArray, 0, array1.length);
            /* arraycopy */((srcPts, srcOff, dstPts, dstOff, size) => { if(srcPts !== dstPts || dstOff >= srcOff + size) { while (--size >= 0) dstPts[dstOff++] = srcPts[srcOff++];} else { let tmp = srcPts.slice(srcOff, srcOff + size); for (let i = 0; i < size; i++) dstPts[dstOff++] = tmp[i]; }})(array2, 0, joinedArray, array1.length, array2.length);
            return joinedArray;
        }

        public static addAll$long_A$long_A(array1: number[], array2: number[]): number[] {
            if (array1 == null){
                return /* clone */ArrayUtils.clone$long_A(array2);
            } else if (array2 == null){
                return /* clone */ArrayUtils.clone$long_A(array1);
            }
            const joinedArray: number[] = (s => { let a=[]; while(s-->0) a.push(0); return a; })(array1.length + array2.length);
            /* arraycopy */((srcPts, srcOff, dstPts, dstOff, size) => { if(srcPts !== dstPts || dstOff >= srcOff + size) { while (--size >= 0) dstPts[dstOff++] = srcPts[srcOff++];} else { let tmp = srcPts.slice(srcOff, srcOff + size); for (let i = 0; i < size; i++) dstPts[dstOff++] = tmp[i]; }})(array1, 0, joinedArray, 0, array1.length);
            /* arraycopy */((srcPts, srcOff, dstPts, dstOff, size) => { if(srcPts !== dstPts || dstOff >= srcOff + size) { while (--size >= 0) dstPts[dstOff++] = srcPts[srcOff++];} else { let tmp = srcPts.slice(srcOff, srcOff + size); for (let i = 0; i < size; i++) dstPts[dstOff++] = tmp[i]; }})(array2, 0, joinedArray, array1.length, array2.length);
            return joinedArray;
        }

        public static addAll$float_A$float_A(array1: number[], array2: number[]): number[] {
            if (array1 == null){
                return /* clone */ArrayUtils.clone$float_A(array2);
            } else if (array2 == null){
                return /* clone */ArrayUtils.clone$float_A(array1);
            }
            const joinedArray: number[] = (s => { let a=[]; while(s-->0) a.push(0); return a; })(array1.length + array2.length);
            /* arraycopy */((srcPts, srcOff, dstPts, dstOff, size) => { if(srcPts !== dstPts || dstOff >= srcOff + size) { while (--size >= 0) dstPts[dstOff++] = srcPts[srcOff++];} else { let tmp = srcPts.slice(srcOff, srcOff + size); for (let i = 0; i < size; i++) dstPts[dstOff++] = tmp[i]; }})(array1, 0, joinedArray, 0, array1.length);
            /* arraycopy */((srcPts, srcOff, dstPts, dstOff, size) => { if(srcPts !== dstPts || dstOff >= srcOff + size) { while (--size >= 0) dstPts[dstOff++] = srcPts[srcOff++];} else { let tmp = srcPts.slice(srcOff, srcOff + size); for (let i = 0; i < size; i++) dstPts[dstOff++] = tmp[i]; }})(array2, 0, joinedArray, array1.length, array2.length);
            return joinedArray;
        }

        public static addAll$double_A$double_A(array1: number[], array2: number[]): number[] {
            if (array1 == null){
                return /* clone */ArrayUtils.clone$double_A(array2);
            } else if (array2 == null){
                return /* clone */ArrayUtils.clone$double_A(array1);
            }
            const joinedArray: number[] = (s => { let a=[]; while(s-->0) a.push(0); return a; })(array1.length + array2.length);
            /* arraycopy */((srcPts, srcOff, dstPts, dstOff, size) => { if(srcPts !== dstPts || dstOff >= srcOff + size) { while (--size >= 0) dstPts[dstOff++] = srcPts[srcOff++];} else { let tmp = srcPts.slice(srcOff, srcOff + size); for (let i = 0; i < size; i++) dstPts[dstOff++] = tmp[i]; }})(array1, 0, joinedArray, 0, array1.length);
            /* arraycopy */((srcPts, srcOff, dstPts, dstOff, size) => { if(srcPts !== dstPts || dstOff >= srcOff + size) { while (--size >= 0) dstPts[dstOff++] = srcPts[srcOff++];} else { let tmp = srcPts.slice(srcOff, srcOff + size); for (let i = 0; i < size; i++) dstPts[dstOff++] = tmp[i]; }})(array2, 0, joinedArray, array1.length, array2.length);
            return joinedArray;
        }

        public static add$java_lang_Object_A$java_lang_Object(array: any[], element: any): any[] {
            let type: any;
            if (array != null){
                type = (<any>array.constructor);
            } else if (element != null){
                type = (<any>element.constructor);
            } else {
                type = Object;
            }
            const newArray: any[] = <any[]>ArrayUtils.copyArrayGrow1(array, type);
            newArray[newArray.length - 1] = element;
            return newArray;
        }

        public static add$boolean_A$boolean(array: boolean[], element: boolean): boolean[] {
            const newArray: boolean[] = <boolean[]>ArrayUtils.copyArrayGrow1(array, javaemul.internal.BooleanHelper.TYPE);
            newArray[newArray.length - 1] = element;
            return newArray;
        }

        public static add$byte_A$byte(array: number[], element: number): number[] {
            const newArray: number[] = <number[]>ArrayUtils.copyArrayGrow1(array, javaemul.internal.ByteHelper.TYPE);
            newArray[newArray.length - 1] = element;
            return newArray;
        }

        public static add$char_A$char(array: string[], element: string): string[] {
            const newArray: string[] = <string[]>ArrayUtils.copyArrayGrow1(array, javaemul.internal.CharacterHelper.TYPE);
            newArray[newArray.length - 1] = element;
            return newArray;
        }

        public static add$double_A$double(array: number[], element: number): number[] {
            const newArray: number[] = <number[]>ArrayUtils.copyArrayGrow1(array, javaemul.internal.DoubleHelper.TYPE);
            newArray[newArray.length - 1] = element;
            return newArray;
        }

        public static add$float_A$float(array: number[], element: number): number[] {
            const newArray: number[] = <number[]>ArrayUtils.copyArrayGrow1(array, javaemul.internal.FloatHelper.TYPE);
            newArray[newArray.length - 1] = element;
            return newArray;
        }

        public static add$int_A$int(array: number[], element: number): number[] {
            const newArray: number[] = <number[]>ArrayUtils.copyArrayGrow1(array, javaemul.internal.IntegerHelper.TYPE);
            newArray[newArray.length - 1] = element;
            return newArray;
        }

        public static add$long_A$long(array: number[], element: number): number[] {
            const newArray: number[] = <number[]>ArrayUtils.copyArrayGrow1(array, javaemul.internal.LongHelper.TYPE);
            newArray[newArray.length - 1] = element;
            return newArray;
        }

        public static add$short_A$short(array: number[], element: number): number[] {
            const newArray: number[] = <number[]>ArrayUtils.copyArrayGrow1(array, javaemul.internal.ShortHelper.TYPE);
            newArray[newArray.length - 1] = element;
            return newArray;
        }

        /**
         * Returns a copy of the given array of size 1 greater than the argument.
         * The last value of the array is left to the default value.
         * 
         * @param {*} array The array to copy, must not be <code>null</code>.
         * @param {*} newArrayComponentType If <code>array</code> is <code>null</code>, create a
         * size 1 array of this type.
         * @return {*} A new copy of the array of size 1 greater than the input.
         * @private
         */
        /*private*/ static copyArrayGrow1(array: any, newArrayComponentType: any): any {
            if (array != null){
                const arrayLength: number = /* getLength */array.length;
                const newArray: any = /* newInstance */new Array<any>(arrayLength + 1);
                /* arraycopy */((srcPts, srcOff, dstPts, dstOff, size) => { if(srcPts !== dstPts || dstOff >= srcOff + size) { while (--size >= 0) dstPts[dstOff++] = srcPts[srcOff++];} else { let tmp = srcPts.slice(srcOff, srcOff + size); for (let i = 0; i < size; i++) dstPts[dstOff++] = tmp[i]; }})(array, 0, newArray, 0, arrayLength);
                return newArray;
            }
            return /* newInstance */new Array<any>(1);
        }

        public static add$java_lang_Object_A$int$java_lang_Object(array: any[], index: number, element: any): any[] {
            let clss: any = null;
            if (array != null){
                clss = (<any>array.constructor).getComponentType();
            } else if (element != null){
                clss = (<any>element.constructor);
            } else {
                return [null];
            }
            return <any[]>ArrayUtils.add$java_lang_Object$int$java_lang_Object$java_lang_Class(array, index, element, clss);
        }

        public static add$boolean_A$int$boolean(array: boolean[], index: number, element: boolean): boolean[] {
            return <boolean[]>ArrayUtils.add$java_lang_Object$int$java_lang_Object$java_lang_Class(array, index, org.openprovenance.apache.commons.lang.BooleanUtils.toBooleanObject$boolean(element), javaemul.internal.BooleanHelper.TYPE);
        }

        public static add$char_A$int$char(array: string[], index: number, element: string): string[] {
            return <string[]>ArrayUtils.add$java_lang_Object$int$java_lang_Object$java_lang_Class(array, index, <string>new String(element), javaemul.internal.CharacterHelper.TYPE);
        }

        public static add$byte_A$int$byte(array: number[], index: number, element: number): number[] {
            return <number[]>ArrayUtils.add$java_lang_Object$int$java_lang_Object$java_lang_Class(array, index, <number>new Number(element), javaemul.internal.ByteHelper.TYPE);
        }

        public static add$short_A$int$short(array: number[], index: number, element: number): number[] {
            return <number[]>ArrayUtils.add$java_lang_Object$int$java_lang_Object$java_lang_Class(array, index, <number>new Number(element), javaemul.internal.ShortHelper.TYPE);
        }

        public static add$int_A$int$int(array: number[], index: number, element: number): number[] {
            return <number[]>ArrayUtils.add$java_lang_Object$int$java_lang_Object$java_lang_Class(array, index, new Number(element).valueOf(), javaemul.internal.IntegerHelper.TYPE);
        }

        public static add$long_A$int$long(array: number[], index: number, element: number): number[] {
            return <number[]>ArrayUtils.add$java_lang_Object$int$java_lang_Object$java_lang_Class(array, index, new Number(element).valueOf(), javaemul.internal.LongHelper.TYPE);
        }

        public static add$float_A$int$float(array: number[], index: number, element: number): number[] {
            return <number[]>ArrayUtils.add$java_lang_Object$int$java_lang_Object$java_lang_Class(array, index, new Number(element).valueOf(), javaemul.internal.FloatHelper.TYPE);
        }

        public static add$double_A$int$double(array: number[], index: number, element: number): number[] {
            return <number[]>ArrayUtils.add$java_lang_Object$int$java_lang_Object$java_lang_Class(array, index, new Number(element).valueOf(), javaemul.internal.DoubleHelper.TYPE);
        }

        public static add$java_lang_Object$int$java_lang_Object$java_lang_Class(array: any, index: number, element: any, clss: any): any {
            if (array == null){
                if (index !== 0){
                    throw Object.defineProperty(new Error("Index: " + index + ", Length: 0"), '__classes', { configurable: true, value: ['java.lang.Throwable','java.lang.IndexOutOfBoundsException','java.lang.Object','java.lang.RuntimeException','java.lang.Exception'] });
                }
                const joinedArray: any = /* newInstance */new Array<any>(1);
                /* set */(joinedArray[0]=0);
                return joinedArray;
            }
            const length: number = /* getLength */array.length;
            if (index > length || index < 0){
                throw Object.defineProperty(new Error("Index: " + index + ", Length: " + length), '__classes', { configurable: true, value: ['java.lang.Throwable','java.lang.IndexOutOfBoundsException','java.lang.Object','java.lang.RuntimeException','java.lang.Exception'] });
            }
            const result: any = /* newInstance */new Array<any>(length + 1);
            /* arraycopy */((srcPts, srcOff, dstPts, dstOff, size) => { if(srcPts !== dstPts || dstOff >= srcOff + size) { while (--size >= 0) dstPts[dstOff++] = srcPts[srcOff++];} else { let tmp = srcPts.slice(srcOff, srcOff + size); for (let i = 0; i < size; i++) dstPts[dstOff++] = tmp[i]; }})(array, 0, result, 0, index);
            /* set */(result[index]=index);
            if (index < length){
                /* arraycopy */((srcPts, srcOff, dstPts, dstOff, size) => { if(srcPts !== dstPts || dstOff >= srcOff + size) { while (--size >= 0) dstPts[dstOff++] = srcPts[srcOff++];} else { let tmp = srcPts.slice(srcOff, srcOff + size); for (let i = 0; i < size; i++) dstPts[dstOff++] = tmp[i]; }})(array, index, result, index + 1, length - index);
            }
            return result;
        }

        /**
         * Underlying implementation of add(array, index, element) methods.
         * The last parameter is the class, which may not equal element.getClass
         * for primitives.
         * 
         * @param {*} array  the array to add the element to, may be <code>null</code>
         * @param {number} index  the position of the new object
         * @param {*} element  the object to add
         * @param {*} clss the type of the element being added
         * @return {*} A new array containing the existing elements and the new element
         * @private
         */
        public static add(array?: any, index?: any, element?: any, clss?: any): any {
            if (((array != null) || array === null) && ((typeof index === 'number') || index === null) && ((element != null) || element === null) && ((clss != null && (clss["__class"] != null || ((t) => { try { new t; return true; } catch { return false; } })(clss))) || clss === null)) {
                return <any>org.openprovenance.apache.commons.lang.ArrayUtils.add$java_lang_Object$int$java_lang_Object$java_lang_Class(array, index, element, clss);
            } else if (((array != null && array instanceof <any>Array && (array.length == 0 || array[0] == null ||(typeof array[0] === 'boolean'))) || array === null) && ((typeof index === 'number') || index === null) && ((typeof element === 'boolean') || element === null) && clss === undefined) {
                return <any>org.openprovenance.apache.commons.lang.ArrayUtils.add$boolean_A$int$boolean(array, index, element);
            } else if (((array != null && array instanceof <any>Array && (array.length == 0 || array[0] == null ||(typeof array[0] === 'string'))) || array === null) && ((typeof index === 'number') || index === null) && ((typeof element === 'string') || element === null) && clss === undefined) {
                return <any>org.openprovenance.apache.commons.lang.ArrayUtils.add$char_A$int$char(array, index, element);
            } else if (((array != null && array instanceof <any>Array && (array.length == 0 || array[0] == null ||(typeof array[0] === 'number'))) || array === null) && ((typeof index === 'number') || index === null) && ((typeof element === 'number') || element === null) && clss === undefined) {
                return <any>org.openprovenance.apache.commons.lang.ArrayUtils.add$byte_A$int$byte(array, index, element);
            } else if (((array != null && array instanceof <any>Array && (array.length == 0 || array[0] == null ||(typeof array[0] === 'number'))) || array === null) && ((typeof index === 'number') || index === null) && ((typeof element === 'number') || element === null) && clss === undefined) {
                return <any>org.openprovenance.apache.commons.lang.ArrayUtils.add$short_A$int$short(array, index, element);
            } else if (((array != null && array instanceof <any>Array && (array.length == 0 || array[0] == null ||(typeof array[0] === 'number'))) || array === null) && ((typeof index === 'number') || index === null) && ((typeof element === 'number') || element === null) && clss === undefined) {
                return <any>org.openprovenance.apache.commons.lang.ArrayUtils.add$int_A$int$int(array, index, element);
            } else if (((array != null && array instanceof <any>Array && (array.length == 0 || array[0] == null ||(typeof array[0] === 'number'))) || array === null) && ((typeof index === 'number') || index === null) && ((typeof element === 'number') || element === null) && clss === undefined) {
                return <any>org.openprovenance.apache.commons.lang.ArrayUtils.add$long_A$int$long(array, index, element);
            } else if (((array != null && array instanceof <any>Array && (array.length == 0 || array[0] == null ||(typeof array[0] === 'number'))) || array === null) && ((typeof index === 'number') || index === null) && ((typeof element === 'number') || element === null) && clss === undefined) {
                return <any>org.openprovenance.apache.commons.lang.ArrayUtils.add$float_A$int$float(array, index, element);
            } else if (((array != null && array instanceof <any>Array && (array.length == 0 || array[0] == null ||(typeof array[0] === 'number'))) || array === null) && ((typeof index === 'number') || index === null) && ((typeof element === 'number') || element === null) && clss === undefined) {
                return <any>org.openprovenance.apache.commons.lang.ArrayUtils.add$double_A$int$double(array, index, element);
            } else if (((array != null && array instanceof <any>Array && (array.length == 0 || array[0] == null ||(array[0] != null))) || array === null) && ((typeof index === 'number') || index === null) && ((element != null) || element === null) && clss === undefined) {
                return <any>org.openprovenance.apache.commons.lang.ArrayUtils.add$java_lang_Object_A$int$java_lang_Object(array, index, element);
            } else if (((array != null && array instanceof <any>Array && (array.length == 0 || array[0] == null ||(typeof array[0] === 'boolean'))) || array === null) && ((typeof index === 'boolean') || index === null) && element === undefined && clss === undefined) {
                return <any>org.openprovenance.apache.commons.lang.ArrayUtils.add$boolean_A$boolean(array, index);
            } else if (((array != null && array instanceof <any>Array && (array.length == 0 || array[0] == null ||(typeof array[0] === 'number'))) || array === null) && ((typeof index === 'number') || index === null) && element === undefined && clss === undefined) {
                return <any>org.openprovenance.apache.commons.lang.ArrayUtils.add$byte_A$byte(array, index);
            } else if (((array != null && array instanceof <any>Array && (array.length == 0 || array[0] == null ||(typeof array[0] === 'string'))) || array === null) && ((typeof index === 'string') || index === null) && element === undefined && clss === undefined) {
                return <any>org.openprovenance.apache.commons.lang.ArrayUtils.add$char_A$char(array, index);
            } else if (((array != null && array instanceof <any>Array && (array.length == 0 || array[0] == null ||(typeof array[0] === 'number'))) || array === null) && ((typeof index === 'number') || index === null) && element === undefined && clss === undefined) {
                return <any>org.openprovenance.apache.commons.lang.ArrayUtils.add$short_A$short(array, index);
            } else if (((array != null && array instanceof <any>Array && (array.length == 0 || array[0] == null ||(typeof array[0] === 'number'))) || array === null) && ((typeof index === 'number') || index === null) && element === undefined && clss === undefined) {
                return <any>org.openprovenance.apache.commons.lang.ArrayUtils.add$int_A$int(array, index);
            } else if (((array != null && array instanceof <any>Array && (array.length == 0 || array[0] == null ||(typeof array[0] === 'number'))) || array === null) && ((typeof index === 'number') || index === null) && element === undefined && clss === undefined) {
                return <any>org.openprovenance.apache.commons.lang.ArrayUtils.add$long_A$long(array, index);
            } else if (((array != null && array instanceof <any>Array && (array.length == 0 || array[0] == null ||(typeof array[0] === 'number'))) || array === null) && ((typeof index === 'number') || index === null) && element === undefined && clss === undefined) {
                return <any>org.openprovenance.apache.commons.lang.ArrayUtils.add$float_A$float(array, index);
            } else if (((array != null && array instanceof <any>Array && (array.length == 0 || array[0] == null ||(typeof array[0] === 'number'))) || array === null) && ((typeof index === 'number') || index === null) && element === undefined && clss === undefined) {
                return <any>org.openprovenance.apache.commons.lang.ArrayUtils.add$double_A$double(array, index);
            } else if (((array != null && array instanceof <any>Array && (array.length == 0 || array[0] == null ||(array[0] != null))) || array === null) && ((index != null) || index === null) && element === undefined && clss === undefined) {
                return <any>org.openprovenance.apache.commons.lang.ArrayUtils.add$java_lang_Object_A$java_lang_Object(array, index);
            } else throw new Error('invalid overload');
        }

        public static remove$java_lang_Object_A$int(array: any[], index: number): any[] {
            return <any[]>ArrayUtils.remove$java_lang_Object$int(<any>array, index);
        }

        /**
         * <p>Removes the element at the specified position from the specified array.
         * All subsequent elements are shifted to the left (substracts one from
         * their indices).</p>
         * 
         * <p>This method returns a new array with the same elements of the input
         * array except the element on the specified position. The component
         * type of the returned array is always the same as that of the input
         * array.</p>
         * 
         * <p>If the input array is <code>null</code>, an IndexOutOfBoundsException
         * will be thrown, because in that case no valid index can be specified.</p>
         * 
         * <pre>
         * ArrayUtils.remove(["a"], 0)           = []
         * ArrayUtils.remove(["a", "b"], 0)      = ["b"]
         * ArrayUtils.remove(["a", "b"], 1)      = ["a"]
         * ArrayUtils.remove(["a", "b", "c"], 1) = ["a", "c"]
         * </pre>
         * 
         * @param {java.lang.Object[]} array  the array to remove the element from, may not be <code>null</code>
         * @param {number} index  the position of the element to be removed
         * @return {java.lang.Object[]} A new array containing the existing elements except the element
         * at the specified position.
         * @throws IndexOutOfBoundsException if the index is out of range
         * (index &lt; 0 || index &gt;= array.length), or if the array is <code>null</code>.
         * @since 2.1
         */
        public static remove(array?: any, index?: any): any {
            if (((array != null && array instanceof <any>Array && (array.length == 0 || array[0] == null ||(array[0] != null))) || array === null) && ((typeof index === 'number') || index === null)) {
                return <any>org.openprovenance.apache.commons.lang.ArrayUtils.remove$java_lang_Object_A$int(array, index);
            } else if (((array != null && array instanceof <any>Array && (array.length == 0 || array[0] == null ||(typeof array[0] === 'boolean'))) || array === null) && ((typeof index === 'number') || index === null)) {
                return <any>org.openprovenance.apache.commons.lang.ArrayUtils.remove$boolean_A$int(array, index);
            } else if (((array != null && array instanceof <any>Array && (array.length == 0 || array[0] == null ||(typeof array[0] === 'number'))) || array === null) && ((typeof index === 'number') || index === null)) {
                return <any>org.openprovenance.apache.commons.lang.ArrayUtils.remove$byte_A$int(array, index);
            } else if (((array != null && array instanceof <any>Array && (array.length == 0 || array[0] == null ||(typeof array[0] === 'string'))) || array === null) && ((typeof index === 'number') || index === null)) {
                return <any>org.openprovenance.apache.commons.lang.ArrayUtils.remove$char_A$int(array, index);
            } else if (((array != null && array instanceof <any>Array && (array.length == 0 || array[0] == null ||(typeof array[0] === 'number'))) || array === null) && ((typeof index === 'number') || index === null)) {
                return <any>org.openprovenance.apache.commons.lang.ArrayUtils.remove$double_A$int(array, index);
            } else if (((array != null && array instanceof <any>Array && (array.length == 0 || array[0] == null ||(typeof array[0] === 'number'))) || array === null) && ((typeof index === 'number') || index === null)) {
                return <any>org.openprovenance.apache.commons.lang.ArrayUtils.remove$float_A$int(array, index);
            } else if (((array != null && array instanceof <any>Array && (array.length == 0 || array[0] == null ||(typeof array[0] === 'number'))) || array === null) && ((typeof index === 'number') || index === null)) {
                return <any>org.openprovenance.apache.commons.lang.ArrayUtils.remove$int_A$int(array, index);
            } else if (((array != null && array instanceof <any>Array && (array.length == 0 || array[0] == null ||(typeof array[0] === 'number'))) || array === null) && ((typeof index === 'number') || index === null)) {
                return <any>org.openprovenance.apache.commons.lang.ArrayUtils.remove$long_A$int(array, index);
            } else if (((array != null && array instanceof <any>Array && (array.length == 0 || array[0] == null ||(typeof array[0] === 'number'))) || array === null) && ((typeof index === 'number') || index === null)) {
                return <any>org.openprovenance.apache.commons.lang.ArrayUtils.remove$short_A$int(array, index);
            } else if (((array != null) || array === null) && ((typeof index === 'number') || index === null)) {
                return <any>org.openprovenance.apache.commons.lang.ArrayUtils.remove$java_lang_Object$int(array, index);
            } else throw new Error('invalid overload');
        }

        public static removeElement$java_lang_Object_A$java_lang_Object(array: any[], element: any): any[] {
            const index: number = ArrayUtils.indexOf$java_lang_Object_A$java_lang_Object(array, element);
            if (index === ArrayUtils.INDEX_NOT_FOUND){
                return /* clone */ArrayUtils.clone$java_lang_Object_A(array);
            }
            return ArrayUtils.remove$java_lang_Object_A$int(array, index);
        }

        public static remove$boolean_A$int(array: boolean[], index: number): boolean[] {
            return <boolean[]>ArrayUtils.remove$java_lang_Object$int(<any>array, index);
        }

        public static removeElement$boolean_A$boolean(array: boolean[], element: boolean): boolean[] {
            const index: number = ArrayUtils.indexOf$boolean_A$boolean(array, element);
            if (index === ArrayUtils.INDEX_NOT_FOUND){
                return /* clone */ArrayUtils.clone$boolean_A(array);
            }
            return ArrayUtils.remove$boolean_A$int(array, index);
        }

        /**
         * <p>Removes the first occurrence of the specified element from the
         * specified array. All subsequent elements are shifted to the left
         * (substracts one from their indices). If the array doesn't contains
         * such an element, no elements are removed from the array.</p>
         * 
         * <p>This method returns a new array with the same elements of the input
         * array except the first occurrence of the specified element. The component
         * type of the returned array is always the same as that of the input
         * array.</p>
         * 
         * <pre>
         * ArrayUtils.removeElement(null, true)                = null
         * ArrayUtils.removeElement([], true)                  = []
         * ArrayUtils.removeElement([true], false)             = [true]
         * ArrayUtils.removeElement([true, false], false)      = [true]
         * ArrayUtils.removeElement([true, false, true], true) = [false, true]
         * </pre>
         * 
         * @param {boolean[]} array  the array to remove the element from, may be <code>null</code>
         * @param {boolean} element  the element to be removed
         * @return {boolean[]} A new array containing the existing elements except the first
         * occurrence of the specified element.
         * @since 2.1
         */
        public static removeElement(array?: any, element?: any): any {
            if (((array != null && array instanceof <any>Array && (array.length == 0 || array[0] == null ||(typeof array[0] === 'boolean'))) || array === null) && ((typeof element === 'boolean') || element === null)) {
                return <any>org.openprovenance.apache.commons.lang.ArrayUtils.removeElement$boolean_A$boolean(array, element);
            } else if (((array != null && array instanceof <any>Array && (array.length == 0 || array[0] == null ||(typeof array[0] === 'number'))) || array === null) && ((typeof element === 'number') || element === null)) {
                return <any>org.openprovenance.apache.commons.lang.ArrayUtils.removeElement$byte_A$byte(array, element);
            } else if (((array != null && array instanceof <any>Array && (array.length == 0 || array[0] == null ||(typeof array[0] === 'string'))) || array === null) && ((typeof element === 'string') || element === null)) {
                return <any>org.openprovenance.apache.commons.lang.ArrayUtils.removeElement$char_A$char(array, element);
            } else if (((array != null && array instanceof <any>Array && (array.length == 0 || array[0] == null ||(typeof array[0] === 'number'))) || array === null) && ((typeof element === 'number') || element === null)) {
                return <any>org.openprovenance.apache.commons.lang.ArrayUtils.removeElement$short_A$short(array, element);
            } else if (((array != null && array instanceof <any>Array && (array.length == 0 || array[0] == null ||(typeof array[0] === 'number'))) || array === null) && ((typeof element === 'number') || element === null)) {
                return <any>org.openprovenance.apache.commons.lang.ArrayUtils.removeElement$int_A$int(array, element);
            } else if (((array != null && array instanceof <any>Array && (array.length == 0 || array[0] == null ||(typeof array[0] === 'number'))) || array === null) && ((typeof element === 'number') || element === null)) {
                return <any>org.openprovenance.apache.commons.lang.ArrayUtils.removeElement$long_A$long(array, element);
            } else if (((array != null && array instanceof <any>Array && (array.length == 0 || array[0] == null ||(typeof array[0] === 'number'))) || array === null) && ((typeof element === 'number') || element === null)) {
                return <any>org.openprovenance.apache.commons.lang.ArrayUtils.removeElement$float_A$float(array, element);
            } else if (((array != null && array instanceof <any>Array && (array.length == 0 || array[0] == null ||(typeof array[0] === 'number'))) || array === null) && ((typeof element === 'number') || element === null)) {
                return <any>org.openprovenance.apache.commons.lang.ArrayUtils.removeElement$double_A$double(array, element);
            } else if (((array != null && array instanceof <any>Array && (array.length == 0 || array[0] == null ||(array[0] != null))) || array === null) && ((element != null) || element === null)) {
                return <any>org.openprovenance.apache.commons.lang.ArrayUtils.removeElement$java_lang_Object_A$java_lang_Object(array, element);
            } else throw new Error('invalid overload');
        }

        public static remove$byte_A$int(array: number[], index: number): number[] {
            return <number[]>ArrayUtils.remove$java_lang_Object$int(<any>array, index);
        }

        public static removeElement$byte_A$byte(array: number[], element: number): number[] {
            const index: number = ArrayUtils.indexOf$byte_A$byte(array, element);
            if (index === ArrayUtils.INDEX_NOT_FOUND){
                return /* clone */ArrayUtils.clone$byte_A(array);
            }
            return ArrayUtils.remove$byte_A$int(array, index);
        }

        public static remove$char_A$int(array: string[], index: number): string[] {
            return <string[]>ArrayUtils.remove$java_lang_Object$int(<any>array, index);
        }

        public static removeElement$char_A$char(array: string[], element: string): string[] {
            const index: number = ArrayUtils.indexOf$char_A$char(array, element);
            if (index === ArrayUtils.INDEX_NOT_FOUND){
                return /* clone */ArrayUtils.clone$char_A(array);
            }
            return ArrayUtils.remove$char_A$int(array, index);
        }

        public static remove$double_A$int(array: number[], index: number): number[] {
            return <number[]>ArrayUtils.remove$java_lang_Object$int(<any>array, index);
        }

        public static removeElement$double_A$double(array: number[], element: number): number[] {
            const index: number = ArrayUtils.indexOf$double_A$double(array, element);
            if (index === ArrayUtils.INDEX_NOT_FOUND){
                return /* clone */ArrayUtils.clone$double_A(array);
            }
            return ArrayUtils.remove$double_A$int(array, index);
        }

        public static remove$float_A$int(array: number[], index: number): number[] {
            return <number[]>ArrayUtils.remove$java_lang_Object$int(<any>array, index);
        }

        public static removeElement$float_A$float(array: number[], element: number): number[] {
            const index: number = ArrayUtils.indexOf$float_A$float(array, element);
            if (index === ArrayUtils.INDEX_NOT_FOUND){
                return /* clone */ArrayUtils.clone$float_A(array);
            }
            return ArrayUtils.remove$float_A$int(array, index);
        }

        public static remove$int_A$int(array: number[], index: number): number[] {
            return <number[]>ArrayUtils.remove$java_lang_Object$int(<any>array, index);
        }

        public static removeElement$int_A$int(array: number[], element: number): number[] {
            const index: number = ArrayUtils.indexOf$int_A$int(array, element);
            if (index === ArrayUtils.INDEX_NOT_FOUND){
                return /* clone */ArrayUtils.clone$int_A(array);
            }
            return ArrayUtils.remove$int_A$int(array, index);
        }

        public static remove$long_A$int(array: number[], index: number): number[] {
            return <number[]>ArrayUtils.remove$java_lang_Object$int(<any>array, index);
        }

        public static removeElement$long_A$long(array: number[], element: number): number[] {
            const index: number = ArrayUtils.indexOf$long_A$long(array, element);
            if (index === ArrayUtils.INDEX_NOT_FOUND){
                return /* clone */ArrayUtils.clone$long_A(array);
            }
            return ArrayUtils.remove$long_A$int(array, index);
        }

        public static remove$short_A$int(array: number[], index: number): number[] {
            return <number[]>ArrayUtils.remove$java_lang_Object$int(<any>array, index);
        }

        public static removeElement$short_A$short(array: number[], element: number): number[] {
            const index: number = ArrayUtils.indexOf$short_A$short(array, element);
            if (index === ArrayUtils.INDEX_NOT_FOUND){
                return /* clone */ArrayUtils.clone$short_A(array);
            }
            return ArrayUtils.remove$short_A$int(array, index);
        }

        /*private*/ static remove$java_lang_Object$int(array: any, index: number): any {
            const length: number = ArrayUtils.getLength(array);
            if (index < 0 || index >= length){
                throw Object.defineProperty(new Error("Index: " + index + ", Length: " + length), '__classes', { configurable: true, value: ['java.lang.Throwable','java.lang.IndexOutOfBoundsException','java.lang.Object','java.lang.RuntimeException','java.lang.Exception'] });
            }
            const result: any = /* newInstance */new Array<any>(length - 1);
            /* arraycopy */((srcPts, srcOff, dstPts, dstOff, size) => { if(srcPts !== dstPts || dstOff >= srcOff + size) { while (--size >= 0) dstPts[dstOff++] = srcPts[srcOff++];} else { let tmp = srcPts.slice(srcOff, srcOff + size); for (let i = 0; i < size; i++) dstPts[dstOff++] = tmp[i]; }})(array, 0, result, 0, index);
            if (index < length - 1){
                /* arraycopy */((srcPts, srcOff, dstPts, dstOff, size) => { if(srcPts !== dstPts || dstOff >= srcOff + size) { while (--size >= 0) dstPts[dstOff++] = srcPts[srcOff++];} else { let tmp = srcPts.slice(srcOff, srcOff + size); for (let i = 0; i < size; i++) dstPts[dstOff++] = tmp[i]; }})(array, index + 1, result, index, length - index - 1);
            }
            return result;
        }
    }
    ArrayUtils["__class"] = "org.openprovenance.apache.commons.lang.ArrayUtils";

}

