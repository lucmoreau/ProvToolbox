package org.openprovenance.prov.template.compiler;

import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.node.ArrayNode;
import com.fasterxml.jackson.databind.node.MissingNode;
import com.squareup.javapoet.ClassName;
import com.squareup.javapoet.FieldSpec;
import com.squareup.javapoet.MethodSpec;
import com.squareup.javapoet.TypeSpec;
import org.openprovenance.prov.model.QualifiedName;
import org.openprovenance.prov.template.descriptors.*;

import javax.lang.model.element.Modifier;
import java.io.*;
import java.util.*;
import java.util.stream.Collectors;

import static org.openprovenance.prov.template.compiler.ConfigProcessor.*;

public class CompilerSQL {
    public static final String SMALL_INDENTATION = "  ";
    private final CompilerUtil compilerUtil=new CompilerUtil();
    ObjectMapper om = new ObjectMapper();
    final public boolean withRelationId;
    private final String tableKey;

    public CompilerSQL(boolean withRelationId, String tableKey) {
        this.withRelationId=withRelationId;
        this.tableKey=tableKey;
    }

    public void generateSQLEnd(String sqlFile, String root_dir) {

        new File(root_dir).mkdirs();

        final String path = root_dir + "/" + sqlFile;


        try {
            PrintStream ps=new PrintStream(new FileOutputStream(path));
            for (String k: tableDeclarations.keySet()) {
                ps.println(tableDeclarations.get(k));
                ps.println("\n\n");
            }

            for (String k: functionDeclarations.keySet()) {
                ps.println(functionDeclarations.get(k));
                ps.println("\n\n");
            }


            ps.close();

        } catch (IOException e) {
            e.printStackTrace();
        }
    }


    Map<String,String> tableDeclarations=new HashMap<>();
    Map<String,String> functionDeclarations=new HashMap<>();

    public void generateSQL(String jsonschema, String templateName, String root_dir, TemplateBindingsSchema templateBindingsSchema) {

        String res="";


        Map<String, List<Descriptor>> var = templateBindingsSchema.getVar();
        Collection<String> variables = descriptorUtils.fieldNames(templateBindingsSchema);

        boolean first = true;

        if (debugComment) res = res + "-- Generated by method " +  getClass().getName()+".generateSQL()\n";


        res=res + "\n" + "CREATE TABLE IF NOT EXISTS " + templateName + "\n(\n";


        if (withRelationId) {

            first=false;
            res=res+ SMALL_INDENTATION + tableKey + " SERIAL" ;
        }

        String documentation=null;

        for (String key: descriptorUtils.fieldNames(templateBindingsSchema)) {

            if (first) {
                first=false;
            } else {
                res=res+ ",\n";
            }

            final String sqlType = convertToSQLType(compilerUtil.getJavaTypeForDeclaredType(var, key).getName());
            Descriptor entry=var.get(key).get(0);
            documentation = retrieveDocumentation(entry);


            if (documentation!=null)  res = res + SMALL_INDENTATION + SMALL_INDENTATION + "--  " + documentation + "\n";
            res=res + SMALL_INDENTATION + sqlify(key) + " " + sqlType;

        }

        res=res+"\n);\n\n";

        tableDeclarations.put(templateName,res);

    }

    private String retrieveDocumentation(Descriptor entry) {
        String documentation=descriptorUtils.getFromDescriptor(entry, AttributeDescriptor::getDocumentation,NameDescriptor::getDocumentation);
        /*String documentation=null;
        switch (entry.getDescriptorType()) {
            case ATTRIBUTE:
                AttributeDescriptor ad=((AttributeDescriptorList) entry).getItems().get(0);
                documentation =ad.getDocumentation();

                break;
            case NAME:
                NameDescriptor nd=(NameDescriptor) entry;
                documentation =nd.getDocumentation();

                break;
        }
         */
        return documentation;
    }

    public void generateSQLstatements(TypeSpec.Builder builder, Set<QualifiedName> allVars, Set<QualifiedName> allAtts, String name, String templateName, JsonNode bindings_schema, TemplateBindingsSchema bindingsSchema) {

        StringBuffer sb=new StringBuffer();
        getInsertStringAndCount(templateName,bindings_schema.get("var"),sb);

        FieldSpec.Builder builder1=FieldSpec.builder(String.class,"_sqlInsert1", Modifier.PRIVATE, Modifier.STATIC);
        builder1.initializer("$S",sb.toString());

        builder.addField(builder1.build());

        builder.addMethod(generateSQLInsert(allVars, allAtts, name, templateName, bindings_schema));
        builder.addMethod(generateSQLInsertStatement(allVars, allAtts, name, templateName, bindings_schema, bindingsSchema));

    }
    public MethodSpec generateSQLInsert(Set<QualifiedName> allVars, Set<QualifiedName> allAtts, String name, String template, JsonNode bindings_schema) {
        final String loggerName = compilerUtil.loggerName(template);
        MethodSpec.Builder builder = MethodSpec.methodBuilder("getSQLInsert")
                .addModifiers(Modifier.PUBLIC)
                .returns(String.class);
        if (debugComment) builder.addComment("Generated by method $N", getClass().getName()+".generateSQLInsert()");
        builder.addStatement("return _sqlInsert1");


        MethodSpec method = builder.build();

        return method;
    }
    public MethodSpec generateSQLInsertStatement(Set<QualifiedName> allVars, Set<QualifiedName> allAtts, String name, String template, JsonNode bindings_schema, TemplateBindingsSchema bindingsSchema) {
        final String loggerName = compilerUtil.loggerName(template);
        MethodSpec.Builder builder = MethodSpec.methodBuilder("getSQLInsertStatement")
                .addModifiers(Modifier.PUBLIC)
                .returns(String.class);
        if (debugComment) builder.addComment("Generated by method $N", getClass().getName()+".generateSQLInsertStatement()");



        JsonNode the_var = bindings_schema.get("var");
        JsonNode the_context = bindings_schema.get("context");


        StringBuffer sb = new StringBuffer();

        int count = getInsertStringAndCount(template, the_var, sb);
        boolean first;

        sb=new StringBuffer();

        sb.append(" VALUES (");

        first=true;
        for (int i=0; i<count; i++) {
            if (first) {
                first=false;
            } else {
                sb.append(", ");
            }
            sb.append("?");
        }
        sb.append(");");

        builder.addStatement("return _sqlInsert1+$S", sb.toString());

        MethodSpec method = builder.build();

        return method;
    }

    public int getInsertStringAndCount(String template, JsonNode the_var, StringBuffer sb) {
        sb.append("INSERT INTO  ");
        sb.append(template);
        sb.append(" (");


        boolean first=true;
        int count=0;

        Iterator<String> iter = the_var.fieldNames();
        while (iter.hasNext()) {
            String key = iter.next();
            if (first) {
                first=false;
            } else {
                sb.append(", ");
            }
            sb.append(sqlify(key));
            count++;
        }

        sb.append(")");
        return count;
    }
    
    Map<String,String> nameMap=initNameMap();

    private Map<String, String> initNameMap() {
        Map<String,String> res=new HashMap<>();
        res.put("order", "_order");
        return res;
    }

    public String sqlify(String key) {
        return nameMap.getOrDefault(key,key);
    }


    String convertToSQLType(String name) {
        switch (name) {
            case "java.lang.String":
                return "TEXT";
            case "java.lang.Integer":
                return "INT";
            case "java.lang.Float":
                return "FLOAT";
            case "java.lang.Boolean":
                return "BOOLEAN";
        }
        throw new UnsupportedOperationException("conversion to SQL type " + name);
    }


    private final boolean debugComment=true;
    public MethodSpec generateClientSQLMethod2(Set<QualifiedName> allVars, Set<QualifiedName> allAtts, String name, String template, JsonNode bindings_schema, TemplateBindingsSchema bindingsSchema)  {
        MethodSpec.Builder builder = MethodSpec.methodBuilder(compilerUtil.sqlName(template) )
                .addModifiers(Modifier.PUBLIC)
                .returns(void.class);
        String var = "sb";

        if (debugComment) builder.addComment("Generated by method $N", getClass().getName()+".generateClientSQLMethod2()");

        JsonNode the_var = bindings_schema.get("var");
        JsonNode the_context = bindings_schema.get("context");

        builder.addParameter(StringBuffer.class, var);
        Iterator<String> iter = the_var.fieldNames();
        while (iter.hasNext()) {
            String key = iter.next();
            String newkey = "__" + key;
            builder.addParameter(compilerUtil.getJavaTypeForDeclaredType(the_var, key), newkey);
        }


        iter = the_var.fieldNames();

        String constant = "(";
        boolean first=true;
        while (iter.hasNext()) {
            String key = iter.next();
            final String newName = "__" + key;
            final Class<?> clazz = compilerUtil.getJavaTypeForDeclaredType(the_var, key);
            final boolean isQualifiedName = the_var.get(key).get(0).get("@id") != null;

            if (first) {
                first=false;
            } else {
                constant = constant + ',';
            }
            builder.addStatement("$N.append($S)", var, constant);
            constant = "";

            if (String.class.equals(clazz)) {
                String myStatement = "$N.append($N)";
                String myEscapeStatement = "$N.append($T.escapeJavaScript($N))";
                boolean doEscape=false;
                if (!isQualifiedName) {
                    doEscape = the_var.get(key).get(0).get(0).get("@escape") != null;
                    if (doEscape) {
                        //foundEscape=true;
                    }
                }
                builder.beginControlFlow("if ($N==null)", newName);
                builder.addStatement("$N.append($S)", var, "''"); // is it correct, or should it be null?
                builder.nextControlFlow("else")
                        .addStatement("$N.append($S)", var, "'");

                if (doEscape) {
                    builder.addStatement(myEscapeStatement, var, ClassName.get("org.openprovenance.apache.commons.lang", "StringEscapeUtils"), newName);
                } else {
                    builder.addStatement(myStatement, var, newName);
                }
                builder.addStatement("$N.append($S)", var, "'")
                        .endControlFlow();
            } else {
                builder.beginControlFlow("if ($N==null)", newName);
                builder.addStatement("$N.append($S)", var, "''");  // is it correct, or should it be null?
                builder.nextControlFlow("else");
                builder.addStatement("$N.append($S)", var, constant);
                builder.addStatement("$N.append($N)", var, newName);
                builder.endControlFlow();
            }
        }
        builder.addStatement("$N.append($S)", var, ")");


        MethodSpec method = builder.build();

        return method;
    }


    public void generateSQLInsertFunction(String jsonschema, String templateName, String root_dir, TemplateBindingsSchema templateBindingsSchema) {

        StringBuilder res= new StringBuilder();


        Map<String, List<Descriptor>> var = templateBindingsSchema.getVar();
        Collection<String> variables = descriptorUtils.fieldNames(templateBindingsSchema);

        final String insertFunctionName=INSERT_PREFIX+templateName;

        boolean first = true;

        if (debugComment) res.append("-- Generated by method ").append(getClass().getName()).append(".generateSQLInsertFunction()\n");


        res.append("\n").append("DROP FUNCTION IF EXISTS ").append(insertFunctionName).append(";\n\n");

        if (debugComment) res.append(" -- function signature");
        res.append("\n").append("CREATE OR REPLACE FUNCTION ").append(insertFunctionName).append("(\n");




        for (String key: descriptorUtils.fieldNames(templateBindingsSchema)) {
            if (descriptorUtils.isInput(key, templateBindingsSchema)) {
                first = sepIfNotFirst(res, first);
                final String defaultSqlType = convertToSQLType(compilerUtil.getJavaTypeForDeclaredType(var, key).getName());
                final String overrideSqlType = descriptorUtils.getSqlType(key, templateBindingsSchema);
                String theSqlType;
                if (overrideSqlType!=null && !NULLABLE_TEXT.equals(overrideSqlType)) {
                    theSqlType=overrideSqlType;
                } else {
                    theSqlType=defaultSqlType;
                }
                res.append(SMALL_INDENTATION).append(ConfigProcessor.INPUT_PREFIX).append(sqlify(key)).append(" ").append(theSqlType);

            }

        }

        res.append("\n)\n");
        if (debugComment) res.append(" -- return\n");

        res.append("returns table(");



        if (withRelationId) {
            res.append(tableKey).append(" INT, ");
        }
        first=true;
        for (String key: descriptorUtils.fieldNames(templateBindingsSchema)) {
            if (descriptorUtils.isOutput(key, templateBindingsSchema)) {
                first = sepIfNotFirst(res, first);
                final String sqlType = convertToSQLType(compilerUtil.getJavaTypeForDeclaredType(var, key).getName());
                res.append(" ").append(sqlify(key)).append(" ").append(sqlType);
            }

        }
        res.append(")\n AS $$\n");

        first=true;
        for (String key: descriptorUtils.fieldNames(templateBindingsSchema)) {
            if (descriptorUtils.isOutputName(key, templateBindingsSchema)) {
                if (first) {
                    if (debugComment) res.append(" -- create new identifiers for outputs\n");
                    res.append("WITH\n");

                }
                first = sepIfNotFirst(res, first, ",\n");
                String the_table= descriptorUtils.getOutputSqlTable(key,templateBindingsSchema).orElse(key);
                String new_table="new_"+key+"_with_id";
                res.append(SMALL_INDENTATION).append(new_table).append(" AS (");
                res.append("\n ").append(SMALL_INDENTATION).append("INSERT INTO ").append(the_table);
                Optional<Map<String, String>> sqlNewInputs = descriptorUtils.getSqlNewInputs(key, templateBindingsSchema);
                if (sqlNewInputs.isPresent()) {
                    Map<String, String> theInputs = sqlNewInputs.get();
                    descriptorUtils.checkSqlInputs(theInputs, key, templateBindingsSchema);
                    List<String> newIns= new ArrayList<>(theInputs.keySet());
                    String columns= newIns.stream().collect(Collectors.joining(",", "(", ")"));
                    res.append("\n ").append(SMALL_INDENTATION).append(columns);
                    res.append(" VALUES ");
                    String inputs= newIns.stream().map(i -> ConfigProcessor.INPUT_PREFIX+sqlify(theInputs.get(i))).collect(Collectors.joining(",", "(", ")"));
                    res.append(inputs);
                } else {
                    res.append("\n ").append(SMALL_INDENTATION).append("DEFAULT VALUES ");
                }
                res.append("\n ").append(SMALL_INDENTATION).append("RETURNING ").append(the_table).append(".ID AS ").append(the_table).append("_id");
                res.append("\n ").append(SMALL_INDENTATION).append(")");
            }
        }


        if (debugComment) res.append("\n -- insert into table");

        res.append("\nINSERT INTO ").append(templateName).append("(");
        first=true;
        for (String key: descriptorUtils.fieldNames(templateBindingsSchema)) {
            first = sepIfNotFirst(res, first);
            res.append(" ").append(sqlify(key));
        }
        res.append(")\n");
        res.append("VALUES\n(");
        first=true;
        int count=1;
        for (String key: descriptorUtils.fieldNames(templateBindingsSchema)) {
            first = sepIfNotFirst(res, first);
            if (count % 5==0) res.append("\n");
            if (descriptorUtils.isInput(key, templateBindingsSchema)) {
                res.append(" ").append(ConfigProcessor.INPUT_PREFIX).append(sqlify(key));
            } else {
                String the_table= descriptorUtils.getOutputSqlTable(key,templateBindingsSchema).orElse(key);
                String new_table="new_"+key+"_with_id";
                String new_id=the_table+"_id";

                //(select obligation_id from obligation_with_id)

                res.append(" ").append("(SELECT ").append(new_id).append(" FROM ").append(new_table).append(") ");
            }
            count ++;
        }
        res.append(")\n");
        if (debugComment) res.append(" -- return result\n");

        res.append("RETURNING ");
        if (withRelationId) {
            res.append(templateName).append(".").append(tableKey).append(", ");
        }
        first=true;
        for (String key: descriptorUtils.fieldNames(templateBindingsSchema)) {
            if (descriptorUtils.isOutput(key, templateBindingsSchema)) {
                first = sepIfNotFirst(res, first);
                res.append(templateName).append(".").append(key);
            }
        }
        res.append(";"); // end returning

        res.append("\n$$ language SQL;");

        functionDeclarations.put(templateName, res.toString());

    }


    private boolean sepIfNotFirst(StringBuilder res, boolean first) {
        return sepIfNotFirst(res,first,", ");
    }

    private boolean sepIfNotFirst(StringBuilder res, boolean first, String sep) {
        if (first) {
            first = false;
        } else {
            res.append(sep);
        }
        return first;
    }


}